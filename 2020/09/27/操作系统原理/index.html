<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="John Doe">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="John Doe">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="第一章 操作系统引论操作系统的设置目标 管理系统资源，达到系统资源的有效利用和共享  合理组织计算机的工作流程，改善系统性能（响应时间、吞吐量）  响应时间：从提出要求到系统做出响应所需时间 吞吐量：单位时间内处理作业的数量   提供用户接口，简化用户使用操作 简而言之就是：方便性、有效性、可扩充性和开放性。   操作系统的定义操作系统是控制和管理计算机系统硬件和软件资源、合理地组织计算机工作流程">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统原理笔记">
<meta property="og:url" content="http://example.com/2020/09/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 操作系统引论操作系统的设置目标 管理系统资源，达到系统资源的有效利用和共享  合理组织计算机的工作流程，改善系统性能（响应时间、吞吐量）  响应时间：从提出要求到系统做出响应所需时间 吞吐量：单位时间内处理作业的数量   提供用户接口，简化用户使用操作 简而言之就是：方便性、有效性、可扩充性和开放性。   操作系统的定义操作系统是控制和管理计算机系统硬件和软件资源、合理地组织计算机工作流程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200911143910130.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912102151988.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912103733486.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912103846344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912103920770.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912103929834.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912104011877.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912152455941.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912162826526.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095443048.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095744859.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095754551.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095829692.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095904036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913144339432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913160929646.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913162557195.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913172019666.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913172710343.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913173235573.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914135746955.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914140501432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914140832626.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914140727368.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914145729236.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914152128036.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914195730141.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914200517585.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914212955182.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914213002042.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914213030702.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914215936765.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200915093457914.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200915094138778.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914233821729.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914234526616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235316172.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914234946125.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235326932.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914234952655.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235339332.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235104023.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235348055.png">
<meta property="og:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235416444.png">
<meta property="article:published_time" content="2020-09-27T02:20:50.339Z">
<meta property="article:modified_time" content="2020-10-07T08:20:41.475Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200911143910130.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>操作系统原理笔记 · Han&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.jpg" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.2.0"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Han&#39;s Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">操作系统原理笔记</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Han's Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            操作系统原理笔记
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">25.7k</span>Reading time: <span class="post-count reading-time">88 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/09/27</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h2><h3 id="操作系统的设置目标"><a href="#操作系统的设置目标" class="headerlink" title="操作系统的设置目标"></a>操作系统的设置目标</h3><ol>
<li><p>管理系统资源，达到系统资源的有效利用和共享</p>
</li>
<li><p>合理组织计算机的工作流程，改善系统性能（响应时间、吞吐量）</p>
<ul>
<li><strong>响应时间</strong>：从提出要求到系统做出响应所需时间</li>
<li><strong>吞吐量</strong>：单位时间内处理作业的数量</li>
</ul>
</li>
<li><p>提供用户接口，简化用户使用操作</p>
<p>简而言之就是：<strong>方便性</strong>、<strong>有效性</strong>、<strong>可扩充性</strong>和<strong>开放性</strong>。</p>
</li>
</ol>
<h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p><strong>操作系统</strong>是控制和管理计算机系统硬件和软件资源、合理地组织计算机工作流程以及方便用户使用计算机系统的程序的集合。</p>
<p><strong>裸机</strong>：计算机系统由硬件系统和软件系统两部分组成，没有配置软件的机器为裸机。</p>
<h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><p>操作系统的目标与<strong>应用环境</strong>有关：在查询系统中所用的OS，希望能提供良好的人—机交互性；对于应用于工业控制、武器控制以及多媒体环境下的OS，要求其具有实时性； 而对于微机上配置的OS，则更看重的是其使用的方便性。</p>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul>
<li>OS作为用户与计算机硬件系统之间的接口</li>
<li>OS作为计算机系统资源的管理者<ul>
<li>处理机管理：用于分配和控制处理机</li>
<li>存储器管理：负责内存的分配与回收</li>
<li>I/O设备管理：负责对I/O设备的分配（回收）与操纵</li>
<li>文件管理：实现对文件的存取、共享和保护</li>
</ul>
</li>
<li>OS实现了对计算机资源的抽象</li>
</ul>
<h3 id="操作系统与硬件、其他软件的层次关系"><a href="#操作系统与硬件、其他软件的层次关系" class="headerlink" title="操作系统与硬件、其他软件的层次关系"></a>操作系统与硬件、其他软件的层次关系</h3><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200911143910130.png" alt="image-20200911143910130"></p>
<h3 id="推动操作系统发展的主要动力"><a href="#推动操作系统发展的主要动力" class="headerlink" title="推动操作系统发展的主要动力"></a>推动操作系统发展的主要动力</h3><ul>
<li>不断提高计算机资源利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
<li>不断提出新的应用需求</li>
</ul>
<h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><h4 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h4><ul>
<li>人工操作方式<ul>
<li>用户独占全机</li>
<li>CPU等待人工操作</li>
</ul>
</li>
<li>脱机输入输出方式<ul>
<li>纸袋上的程序和数据脱机输入到磁带上</li>
<li>优点：1. 减少了CPU的空闲时间；2. 提高了I/O速度</li>
</ul>
</li>
</ul>
<h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><ul>
<li>特点：顺序性；自动性；单道性</li>
<li>缺点：CPU等待I/O；内存浪费；I/O设备浪费</li>
</ul>
<h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><ul>
<li><p><strong>多道程序设计</strong>的基本概念：用户所提交的作业先存放在外存上，并排成一个队列，称为“<strong>后备队列</strong>”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</p>
</li>
<li><p>特征：多道性；无序性；调度性（两级）</p>
</li>
<li>优点：资源利用率高；系统吞吐量大</li>
<li>缺点：平均周转时间长；无交互能力</li>
<li>需要解决的问题：处理机争用问题；内存分配和保护问题；I/O设备分配问题；文件的组织和管理问题；作业管理问题；用户与系统的接口问题</li>
</ul>
<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><ul>
<li><p>分时系统是指在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统与允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。（<strong>人——机交互</strong>和<strong>共享主机</strong>）。</p>
</li>
<li><p>实现思想：把CPU时间进行分割成一定大小的时间段，每个时间段称为一个时间片；每个终端用户每次可以使用一个由时间片规定的CPU时间，多个终端用户就轮流地使用CPU。（如果某个用户在规定的一个时间片内还没有完成它的全部工作，亦需把CPU让给其他用户，等待下一轮再使用一个时间片的CPU时间，循环轮转，直至结束）</p>
</li>
<li><p>关键问题</p>
<ul>
<li><p>及时接收：能及时的接收来自终端用户的命令</p>
</li>
<li><p>及时处理：能及时的响应用户输入的命令，响应时间要短</p>
<ul>
<li>响应时间：指从用户输入命令后到系统将处理结果提交给用户所经历的时间</li>
</ul>
<p>影响响应时间的因素 $响应 时间=N*q+系统开销$</p>
<p>​        时间片q；系统开销；用户数N；对换信息量。</p>
</li>
</ul>
</li>
<li><p>分时系统的特征：</p>
<ul>
<li>多路性</li>
<li>独立性</li>
<li>及时性</li>
<li>交互性</li>
</ul>
</li>
</ul>
<h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><ul>
<li>实时：指计算机对随机发生的外部事件做出及时的响应并对其进行处理<ul>
<li>外部事件：指来自与计算机系统所连接的设备所提出的服务要求</li>
</ul>
</li>
<li>实时系统的分类<ul>
<li>实时过程控制</li>
<li>实时信息处理</li>
</ul>
</li>
<li>实时系统的特征<ul>
<li>多路性</li>
<li>交互性</li>
<li>独立性</li>
<li>可靠性</li>
<li>及时性</li>
</ul>
</li>
<li>实时任务的类型<ul>
<li>周期性实时任务/非周期性实时任务</li>
<li>每一个人物都有一个截止时间：开始截止时间、完成截止时间</li>
<li>根据对截止时间的要求划分：硬实时任务/软实时任务</li>
</ul>
</li>
<li>实时系统与批处理、分时系统的区别<ul>
<li>属“专用系统”，处理程序常驻主存</li>
<li>有较强的中断处理机构、分析机构</li>
<li>有较高的精度和可靠性</li>
</ul>
</li>
</ul>
<h4 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h4><ul>
<li>单用户单任务</li>
<li>单用户多任务</li>
<li>多用户多任务</li>
</ul>
<h3 id="操作系统的特征和性能"><a href="#操作系统的特征和性能" class="headerlink" title="操作系统的特征和性能"></a>操作系统的特征和性能</h3><h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><ul>
<li>并发和并行<ul>
<li>并发性是指两个或多个事件在同一时间间隔内发生</li>
<li>并行性是指两个或多个事件在同一时刻发生</li>
</ul>
</li>
<li>共享<ul>
<li>OS环境下的资源共享：资源复用，系统中的资源可供内存中多个并发执行的进程共同使用</li>
<li>共享方式：互斥共享/同时访问</li>
</ul>
</li>
<li>异步<ul>
<li>进程的异步性：进程以人们无法预知的速度向前推进</li>
<li>进程同步机制：保障作业的多次运行都能获得相同结果</li>
</ul>
</li>
<li>虚拟<ul>
<li>OS中，通过某种技术将一个物理实体变为阮淦个逻辑上的对应物的功能称为“虚拟“</li>
<li>时分复用技术/空分复用技术</li>
</ul>
</li>
</ul>
<p>并发和共享是操作系统的两个最基本的特征，它们又是互为存在的条件</p>
<p>虚拟和异步性是操作系统的两个重要特征，虚拟技术为共享提供了更好的条件，而并发与共享是导致不确定性的根本原因</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p><strong>系统效率</strong></p>
<ul>
<li>资源的利用率要高。处理机空闲时间要少，内存利用率高，外部设备利用均衡</li>
<li>对批处理系统来说，作业的平均周转时间要短，吞吐量要大</li>
<li>对分时系统来说，其响应时间要尽量短</li>
</ul>
<p><strong>系统可靠性与安全性</strong></p>
<ul>
<li>操作系统的可靠性与安全性直接影响着整个计算机系统的运行可靠性与安全性</li>
<li>用户的误操作也可能造成系统工作不正常</li>
<li>能及时检测出错误，并能尽量准确的指出错误发生的原因，采取相应的措施排除错误</li>
<li>对错误产生的损害，能进行修复，使系统恢复正常工作，尽量减少损失，具有较好的健壮性</li>
</ul>
<p><strong>系统可维护性</strong></p>
<ul>
<li>操作系统往往是一个庞大的软件集合，对操作系统进行纠错性维护是必须的</li>
<li>随着应用领域的扩大，硬件的扩充，计算机体系结构的变化，新功能的增加，都将要求对操作系统进行修改维<br>护，这就要求操作系统有较好的结构，完备的文档，以便于维护</li>
<li>操作系统是否具有较好的维护性是决定操作系统生命周期长短的重要因素</li>
</ul>
<p><strong>方便性</strong></p>
<ul>
<li>系统提供的各种服务方便用户使用</li>
</ul>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul>
<li>处理机管理<ul>
<li>进程控制</li>
<li>进程同步</li>
<li>进程通信</li>
<li>调度</li>
</ul>
</li>
<li>存储器管理<ul>
<li>内存分配</li>
<li>内存保护</li>
<li>地址映射</li>
<li>内存扩充</li>
</ul>
</li>
<li>设备管理<ul>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理</li>
</ul>
</li>
<li>文件管理<ul>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读/写管理和保护</li>
</ul>
</li>
<li>系统与用户之间的接口<ul>
<li>用户接口</li>
<li>程序接口</li>
</ul>
</li>
<li>现代操作系统的新功能<ul>
<li>系统安全</li>
<li>网络功能和服务</li>
<li>支持多媒体</li>
</ul>
</li>
</ul>
<h2 id="第二章-操作系统结构"><a href="#第二章-操作系统结构" class="headerlink" title="第二章 操作系统结构"></a>第二章 操作系统结构</h2><h3 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h3><ul>
<li>计算机硬件——提供基本的计算机资源</li>
<li>操作系统——控制和协调计算机软硬件资源，方便用户使用</li>
<li>应用程序</li>
<li>用户——人、设备、其他计算机</li>
</ul>
<h4 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h4><ul>
<li>CPU</li>
<li>存储器</li>
<li>磁盘</li>
<li>I/O设备</li>
</ul>
<h4 id="计算机系统结构"><a href="#计算机系统结构" class="headerlink" title="计算机系统结构"></a>计算机系统结构</h4><ul>
<li>现代通用计算机系统由一个或多个CPU和若干设备控制器通过共同的总线相连而成，该总线提供了对共享内存的访问</li>
<li>每个设备控制器负责一种特定类型的设备，CPU与设备控制器可以并发工作，并竞争内存周期</li>
<li>为了确保共享内存的有序访问，需要内存控制器来协调对内存的访问</li>
</ul>
<h4 id="计算机系统运行"><a href="#计算机系统运行" class="headerlink" title="计算机系统运行"></a>计算机系统运行</h4><p><strong>计算机启动</strong></p>
<ul>
<li>存储在ROM或EPROM种的启动加载程序自动运行，初始化系统并将操作系统内核装入内存中</li>
<li>多个非接式读写头并行移动访问：柱面</li>
</ul>
<p><strong>常规运行</strong></p>
<ul>
<li>I/O设备和CPU并行</li>
<li>每种设备控制器控制一类设备，设备控制器都具有局部缓存</li>
<li>CPU通过局部缓存和贮存交换数据，I/O从设备到设备控制器的局部缓存，设备控制器通过引起<strong><em>中断</em></strong>通知CPU操作已完成</li>
</ul>
<h3 id="操作系统的运行"><a href="#操作系统的运行" class="headerlink" title="操作系统的运行"></a>操作系统的运行</h3><ul>
<li>操作系统是由中断驱动的</li>
<li>自陷是由软件产生的中断，通常由执行指令的错误或用户请求产生</li>
<li>操作和用户共享计算机系统的软硬件资源，OS必须预防和控制<ul>
<li>软件异常或自陷</li>
<li>其他进程问题：无限循环、进程篡改OS</li>
</ul>
</li>
<li>硬件保护机制<ul>
<li>双模式和多模式操作</li>
<li>计时器</li>
</ul>
</li>
</ul>
<h4 id="硬件保护"><a href="#硬件保护" class="headerlink" title="硬件保护"></a>硬件保护</h4><p><strong>双模式操作</strong></p>
<ul>
<li>设置内核模式（或称为系统模式/内核态/系统态）和和用户模式（或称为用户态） ，PSW中设置模式位=<strong>0/1指示当前模式</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912102151988.png" alt="image-20200912102151988"></p>
<ul>
<li>当系统引导时，硬件从内核模式开始。操作系统接着加载，然后开始在用户模式下执行用户程序；一旦有自陷或中断，硬件会从用户模式切换到内核模式</li>
<li>将可能引起损害的机器指令设为特权指令（privileged instruction)，且只在内核模式下才允许执行</li>
<li>用户模式下通过<strong>系统调用</strong>请求OS执行特权指令</li>
<li>特权指令包括：切换到用户模式的指令、I/O 控制、定时器管理和中断管理等</li>
</ul>
<p><strong>多模式操作</strong></p>
<ul>
<li>PSW可以设置多个模式位</li>
<li>除了模式外，CPU 设计人员也可采用其他方式来区分执行特权。</li>
</ul>
<p><strong>定时器</strong></p>
<ul>
<li>为了防止用户程序陷入死循环，或不将控制返给操作系统，OS可以使用定时器</li>
<li>定时器可设置为在指定周期后中断计算机，指定周期可以是固定或可变的</li>
<li><strong>可变定时器</strong>—般通过一个固定速率的时钟和计数器来实现<ul>
<li>操作系统设置计数器每次时钟滴答时，计数器都要递减</li>
<li>当计数器的值为0 时，就会产生中断</li>
</ul>
</li>
<li>用于修改定时器的指令是特权指令</li>
</ul>
<h3 id="操作系统服务"><a href="#操作系统服务" class="headerlink" title="操作系统服务"></a>操作系统服务</h3><ul>
<li>用户界面：命令行界面和图形用户界面</li>
<li>程序执行：系统必须能将程序装入内存并执行</li>
<li>I/O操作：运行程序可能需要I/O，这些I/O可能涉及文件或设备</li>
<li>文件系统操作：程序需要读写文件和目录，还包括了对文件或目录的访问管理</li>
<li>通信：进程之间的信息交换通过共享内存或消息交换实现</li>
<li>错误检测：OS需要知道可能出现的错误</li>
<li>资源分配：系统为多个用户或作业分配资源</li>
<li>统计：记录哪些用户使用了多少和什么类型的资源</li>
<li>保护和安全</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><strong>系统调用</strong>提供了操作系i同提供的有效服务接口</p>
<p><strong>应用程序接口API</strong>是程序员在用户空间下可以直接使用的函数接口</p>
<ul>
<li>都是一组函数，系统调用的实现实在内核中完成，API实在函数库种实现</li>
<li>一个API也可能由多个系统调用实现，一个API的功能可能并不需要内核提供的服务，那么此时这个API也就不需要任何的系统调用</li>
<li>常用API：Win32 API;POSIX API;Java API</li>
</ul>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><h4 id="单一体结构"><a href="#单一体结构" class="headerlink" title="单一体结构"></a>单一体结构</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912103733486.png" alt="image-20200912103733486"></p>
<ul>
<li>全部操作系统在内核态中以单一程序的方式运行，整个OS以过程集合的方式编写，链接成一个大型可执行二进制程序</li>
<li>各个功能归为不同的功能块，每个功能块相对独立，又经过固定的界面相互联系</li>
<li>网状关系容易造成循环调用，形成死锁，降低OS可靠性</li>
</ul>
<h4 id="层次式结构"><a href="#层次式结构" class="headerlink" title="层次式结构"></a>层次式结构</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912103846344.png" alt="image-20200912103846344"></p>
<p>将单一体OS的功能分成不同层次，底层次的功能为其紧邻其上的一个层次的功能提供服务</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912103920770.png" alt="image-20200912103920770"></p>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912103929834.png" alt="image-20200912103929834"></p>
<ul>
<li>为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个核心模块——微内核——运行在内核态，其他模块则作为普通用户进程运行</li>
<li>设备驱动和文件系统作为普通用户进程，模块中的错误会使模块崩溃，但不会使整个系统死机</li>
<li>典型代表：MINIX 3</li>
</ul>
<h4 id="客户机-服务器模式"><a href="#客户机-服务器模式" class="headerlink" title="客户机-服务器模式"></a>客户机-服务器模式</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912104011877.png" alt="image-20200912104011877"></p>
<ul>
<li>客户机—服务器模式是微内核的变体，是一种可应用在单机或网络机器上的抽象</li>
<li>客户端和服务器之间的通信是消息传递</li>
<li>越来越多的系统，包括家用PC机都成为了客户端，而某地运行的大型机则成为服务器</li>
</ul>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li><p>用面向对象编程技术来生成模块化的内核，内核有一组核心部件和在启动或运行时加载服务的动态链接</p>
</li>
<li><p>这种方法使用动态加载模块，并广泛用于现代的UNIX中</p>
</li>
<li>内核提供核心服务，也能动态地实现特定功能<ul>
<li>类似分层系统，每个内核部分都有被定义和保护的接口，但比分层系统更灵活，任一模块都能调用其他模块</li>
<li>类似微内核方法，但实施更加高效，因为不需要调用消息传递来通信</li>
</ul>
</li>
</ul>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p><strong>虚拟机</strong>的基本思想：单个计算机（CPU、内存、磁盘、网卡等）的硬件抽象为几个不同的执行部件，从而造成一种“幻觉”，仿佛每个独立的执行环境都在自己的计算机上运行一样</p>
<ul>
<li>虚拟机技术：将事物从一种形式转变成另一种形式<ul>
<li>操作系统中内存的虚拟化</li>
<li>虚拟专用网技术（VPN）</li>
</ul>
</li>
<li>创建虚拟机的原因：在并行运行的几个不同的执行环境（不同的操作系统）时能够共享相同的硬件</li>
<li>优点：<ul>
<li>提供良好的安全性：资源共享是间接实现的，不同<br>系统资源具有完全保护</li>
<li>提供用于研究和开发OS的好工具</li>
</ul>
</li>
</ul>
<h2 id="第三章-进程与线程"><a href="#第三章-进程与线程" class="headerlink" title="第三章 进程与线程"></a>第三章 进程与线程</h2><h3 id="前驱图和程序执行"><a href="#前驱图和程序执行" class="headerlink" title="前驱图和程序执行"></a>前驱图和程序执行</h3><h4 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h4><p>由多个结点构成的有向无循环图(DAG)，称为<strong>前趋图</strong></p>
<ul>
<li>用于描述程序中操作间的关系，图中每个结点可以表示一条语句、一个程序段或进程</li>
</ul>
<p>前趋关系/偏序</p>
<ul>
<li>若两个节点$P_i$，$P_j$，仅当$P_i$操作完成后，才能执行$P_j$结点的操作，称$P_i，P_j$之间存在前趋关系，表示为：$P_i→P_j，$前趋关系$“→”$用集合表示为：$\{(P_i,P_j)|仅当P_i完成，才能执行P_j\}$</li>
</ul>
<h4 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h4><p>特征</p>
<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
<h4 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><p>考虑各种并发性的程序设计方法称为<strong>并发程序设计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发程序</span></span><br><span class="line">Parbegin</span><br><span class="line">	S1; S2; ...; Sn;</span><br><span class="line">Parend;</span><br><span class="line"><span class="comment">//Parbegin/Parend 可以嵌套</span></span><br><span class="line"><span class="comment">//Si 可为任何简单句、复合句和并发语句；编译时，编译程序为其设置一个进程</span></span><br></pre></td></tr></table></figure>
<p>特征</p>
<ul>
<li>间断性</li>
<li>失去封闭性：程序的执行环境受其他程序影响</li>
<li>不可再现性：并发执行时失去封闭性，执行结果与并发程序的执行速度相关，导致其失去可再现性</li>
</ul>
<h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><p><strong>进程</strong>：一个具有一定独立功能的可并发执行的程序，在一个数据集合上的运行过程</p>
<p>为了使参与并发执行的每个程序（含数据）都能独立运行，在操作系统中必须为之配置一个专门的数据结构，称为<strong>进程控制块（PCB）</strong></p>
<p><strong>进程实体=程序+数据+PCB</strong></p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
<p><strong>进程特征</strong></p>
<ul>
<li>动态性：进程是一次运行过程，有生命周期（最基本特征）</li>
<li>并发性：可并发执行</li>
<li>独立性：进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</li>
<li>异步性：进程按照各自独立的、不可预知的速度向前推进</li>
</ul>
<h4 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h4><ul>
<li>进程是程序的一次运行过程，是一个动态实体，而程序是一个指令的集合，是静态实体</li>
<li>进程具有生命周期，具有创建、执行和撤销的过程，而程序一旦创建，可以永远存在</li>
<li>进程实体由程序段、数据段及进程控制块组成</li>
<li>进程与程序之间不存在一一对应的关系，不同的进程可以对应相同的程序，一个进程中还可以同时调用多个程序</li>
<li>进程实体是一个能独立运行的基本单位，可独立获得资源和独立调度；而程序不能作为独立的单位参加运行</li>
<li>进程可按异步方式运行，程序不是运行实体，所以不可以异步执行</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>三个基本状态</p>
<ul>
<li>运行状态：指令正被执行</li>
<li>就绪状态：进程等待分配CPU</li>
<li>阻塞状态：进程等待事件（一般指I/O事件）的发生</li>
</ul>
<p>新建状态和终止状态</p>
<ul>
<li>新建状态：刚被创建，尚未进入就绪队列时的状态</li>
<li>终止状态：进程正常/异常结束，移出就绪队列，但尚未撤销时的状态</li>
</ul>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912152455941.png" alt="image-20200912152455941"></p>
<p><strong>进程的挂起/解挂状态</strong></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200912162826526.png" alt="image-20200912152455941"></p>
<p>设置进程挂起/解挂状态的原因</p>
<ul>
<li>用户需要：中间结果与预期不符</li>
<li>操作系统需要：系统某些功能故障</li>
<li>系统负荷过重</li>
<li>父进程请求：修改或协调子进程</li>
<li>对换的需要</li>
</ul>
<p>设置挂起状态后进程状态的转换</p>
<p>设置挂起状态后，进程的就绪、阻塞状态分别分为：</p>
<ul>
<li>活动就绪、静止就绪</li>
<li>活动阻塞、静止阻塞</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>PCB是用以记录与进程相关信息的主存区，是进程存在的唯一标志</p>
<h4 id="PCB主要内容"><a href="#PCB主要内容" class="headerlink" title="PCB主要内容"></a>PCB主要内容</h4><ul>
<li>进程标识信息<ul>
<li>进程本身</li>
<li>家族信息</li>
</ul>
</li>
<li>处理机状态信息</li>
<li>进程调度信息</li>
<li>进程控制信息</li>
<li><ul>
<li>程序、数据的外存</li>
<li>进程同步和通信机制：消息队列、信号量</li>
<li>资源清单（除CPU外）</li>
<li>链接指针</li>
</ul>
</li>
</ul>
<h4 id="PCB组织方式"><a href="#PCB组织方式" class="headerlink" title="PCB组织方式"></a>PCB组织方式</h4><ul>
<li>线性方式：系统中所有PCB都组织在一张线性表中，表的首地址存放在内存专用区</li>
<li>链接方式：具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列</li>
<li>索引方式：系统根据所有进程状态的不同，建立几张索引表，并把索引表的首地址记录在内存的专用单元中</li>
</ul>
<h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><p>现代操作系统设计采用层次结构，往往将一些与硬件紧密相关的模块或运行频率较高的模块设置在第一层软件中，称为<strong>操作系统的内核</strong></p>
<p>内核的基本功能：</p>
<ul>
<li>支撑功能：中断处理、时钟管理、原语操作<ul>
<li>原语操作：一个操作中的所有动作不可分割</li>
</ul>
</li>
<li>管理功能：<ul>
<li>进程管理：调度、创建、同步等</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
</li>
</ul>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p><strong>进程图</strong>：用于描述进程家族关系的有向树</p>
<p>进程图：结点代表进程， $P_i→P_j$表示$P_i$创建了$P_j$</p>
<p>进程图与前趋图的2个区别：</p>
<ol>
<li>表示的含义不同；</li>
<li>执行时处理不同：可并发执行</li>
</ol>
<p><strong>引起进程创建的事件</strong></p>
<ul>
<li>用户登录：分时系统</li>
<li>作业调度</li>
<li>提供服务：系统随时创建各类服务进程</li>
<li>应用请求：进程执行时根据需要创建子进程</li>
</ul>
<p><strong>主要步骤</strong></p>
<ul>
<li>申请空白PCB</li>
<li>为新进程分配资源</li>
<li>初始化PCB</li>
<li>将新进程插入就绪队列</li>
</ul>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><p><strong>引起进程终止的事件</strong></p>
<ul>
<li>正常结束</li>
<li>异常结束：越界错误、特权指令错、算术运算错等</li>
<li>外界干预：操作员或操作系统干预、父进程干预</li>
</ul>
<p><strong>主要步骤</strong></p>
<ul>
<li>根据终止进程标识符，找到对应PCB</li>
<li>若该进程正在执行，终止进程，设置调度标志为真</li>
<li>如果该进程具有子孙进程，则终止其所有子孙</li>
<li>回收所有资源，归还给其父进程或系统</li>
<li>将PCB移出原所在队列</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>协作进程需要一种进程间通信机制来允许进程相互交互数据与信息</p>
<p>进程通信类型</p>
<ul>
<li>共享存储器系统<ul>
<li>共享数据结构：信息交换的格式、类型一定；进程通信由程序员完成，效率低；</li>
<li>共享存储区：进程可随时向系统申请一块存储区，并指定该分区的关键字，用于进程通信</li>
</ul>
</li>
<li>消息传递系统</li>
<li>管道通信</li>
</ul>
<h4 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h4><p>消息传递系统：利用系统提供的通信原语，以消息或报文为单位进行信息交换，包括直接/间接通信：</p>
<ul>
<li>直接通信方式<ul>
<li>一个进程直接把消息发送给目标进程</li>
</ul>
</li>
<li>间接通信方式<ul>
<li>进程之间通过某种共享的数据结构（如信箱）进行通信，信箱通信原语有<ul>
<li>信箱的创建、撤销</li>
<li>消息的发送和接受</li>
</ul>
</li>
<li>信箱分为三类<ul>
<li>私用信箱</li>
<li>共用信箱</li>
<li>共享信箱</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通信链路</p>
<ul>
<li>显式建立/隐式建立（发送原语自动构建）</li>
<li>单向通信链路/双向通信链路</li>
</ul>
<p>消息格式</p>
<ul>
<li>消息头：发送和接收进程名、消息长度、类型…</li>
<li>消息正文</li>
</ul>
<p>进程同步的三种方式</p>
<ul>
<li>发送者、接收者进程阻塞</li>
<li>发送者不阻塞、接收者进程阻塞</li>
<li>发送者、接收者进程都不阻塞</li>
</ul>
<p><strong>消息缓冲队列通信机制</strong></p>
<p>根据“生产者——消费者”原理，利用内存中公用消息缓冲区实现进程间的信息交换</p>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p>管道：用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称为Pipe文件</p>
<h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>为了使多个程序并发执行，提高资源利用率和系统效率，OS引入了<strong>进程</strong><br>为了减少程序并发执行带来的时空开销，使得并发粒度更细、并发性更好，OS引入了<strong>线程</strong></p>
<p><strong>为什么要引入线程</strong></p>
<ul>
<li>进程的独立性特征可分为两方面：1、是拥有资源的基本单位；2、是可被独立调度的基本单位</li>
<li>由于其拥有较多资源，使得在进程创建、切换时系统须付出较大的时空开销，限制了并发程度的进一步提高</li>
<li>因此，将进程独立性的两个属性分开，引入了线程</li>
</ul>
<p><strong>线程的定义</strong></p>
<p>线程：是进程中的一个实体，是能被系统独立调度和分派的基本单位</p>
<p><strong>线程的组成</strong></p>
<ul>
<li>线程ID</li>
<li>寄存器集合</li>
<li>程序计数器</li>
<li>栈</li>
</ul>
<p><strong>多线程的优点</strong></p>
<ul>
<li>响应度高：只需要阻塞部分线程，提高了对用户的响应</li>
<li>资源共享：线程默认共享所属进程的内存和资源</li>
<li>经济：创建和切换线程的代价更小</li>
<li>多处理器体系结构的利用：在多CPU上提高了并行性</li>
</ul>
<h4 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h4><p>线程：轻量进程</p>
<ul>
<li>调度：线程成为调度和分派的基本单位，同一进程内的线程切换不会引起进程切换</li>
<li>并发性：线程与线程、进程与进程都可以并发执行</li>
<li>拥有资源：进程是操作系统种拥有资源的最基本单位，线程共享进程的资源，自己并不拥有</li>
<li>独立性：同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多</li>
<li>系统开销：线程的系统开销远比进程小，且更容易实现通信和同步</li>
<li>支持多处理机系统：进程只能分配到一个CPU上执行，同一进程内的多个线程可分配到多个CPU上并行执行</li>
</ul>
<h4 id="线程类型"><a href="#线程类型" class="headerlink" title="线程类型"></a>线程类型</h4><p>内核支持线程</p>
<p>用户级线程</p>
<h4 id="线程的执行"><a href="#线程的执行" class="headerlink" title="线程的执行"></a>线程的执行</h4><p>状态及转换</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095443048.png" alt="image-20200913095443048"></p>
<p>三个基本状态</p>
<ul>
<li>就绪</li>
<li>执行</li>
<li>阻塞</li>
</ul>
<p>线程的基本操作</p>
<ul>
<li>派生：在进程内，由进程本身或其他线程派生出新的线程，放入就绪队列</li>
<li>调度：选择一个线程分配CPU执行</li>
<li>阻塞：线程因等待某个事件发生而被阻塞，阻塞线程后，寄存器上下文、程序计数器、堆栈指针都将被保存</li>
<li>激活：线程等待的事件发生后，将被激活后进入就绪队列</li>
<li>结束：线程执行完毕后被结束，其寄存器上下文和堆栈都将被释放</li>
</ul>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095744859.png" alt="image-20200913095744859"></p>
<ul>
<li>用户线程均映射到一个内核线程</li>
<li>线程管理是由线程库在用户空间进行的，效率高</li>
<li>某个用户线程因需要访问内核而阻塞时，会引起整个进程的阻塞</li>
<li>任意时刻，只有一个线程能够访问内核，因此无法并行运行在多处<br>理器上</li>
</ul>
<h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095754551.png" alt="image-20200913095754551"></p>
<ul>
<li>每一个用户线程均映射到一个内核线程</li>
<li>一个用户线程因需要访问内核而阻塞时，另一个用户线程能够继续执行，多个线程可以并行运行在多处理器上</li>
<li>要为每一个用户线程创建对应的内核线程，开销大，影响应用程序性能，整个系统的线程数量受限</li>
<li>实例：Linux和Windows系列都实现了该模型</li>
</ul>
<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095829692.png" alt="image-20200913095829692"></p>
<ul>
<li>多个用户线程映射到数量相等或更少的多个内核线程上，内核进程的数量可能与特定应用或特定硬件有关</li>
<li>结合了多对一和一对一模型的优点：可以创建任意数量的用户线程，相应内核线程可在多处理器系统上并发执<br>行；当某个线程执行阻塞系统调用时，内核能调度另一线程执行</li>
</ul>
<h4 id="二级模型：多对多模型变种"><a href="#二级模型：多对多模型变种" class="headerlink" title="二级模型：多对多模型变种"></a>二级模型：多对多模型变种</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913095904036.png" alt="image-20200913095904036"></p>
<ul>
<li>多对多模型的基础上，允许一个用户线程绑定到某个内核线程上</li>
</ul>
<h2 id="第四章进程调度"><a href="#第四章进程调度" class="headerlink" title="第四章进程调度"></a>第四章进程调度</h2><h3 id="三级调度模型"><a href="#三级调度模型" class="headerlink" title="三级调度模型"></a>三级调度模型</h3><ul>
<li><p>高级调度（作业调度）</p>
<ul>
<li>按照一定的算法从后备队列中选择满足条件的作业，分配一定资源，创建PCB，入内存就绪队列</li>
<li>调度间隔为几秒或几分钟，不如进程调度频繁，因此称为长程调度</li>
<li>决定了多道批处理系统的道数</li>
</ul>
</li>
<li><p>低级调度（进程调度）</p>
<ul>
<li>按照一定的算法从就绪队列中选择满足条件的进程，分配CPU</li>
<li>分为抢占式/非抢占式</li>
<li>调度间隔为几毫秒甚至更短，因此称为短程调度</li>
</ul>
</li>
<li><p>中级调度</p>
<ul>
<li>将在主存中长期得不到执行的进程，按照一定的算法放入磁盘交换区，满足执行条件后再入内存</li>
</ul>
</li>
</ul>
<h3 id="进程调度的基本概念"><a href="#进程调度的基本概念" class="headerlink" title="进程调度的基本概念"></a>进程调度的基本概念</h3><p><strong>作业调度时选择I/O约束程序和CPU约束程序同时入主存，能提高资源利用率</strong></p>
<ul>
<li>进程的执行是由多个CPU执行区间和I/O执行区间交替组成的</li>
<li>I/O约束程序（I/O密集型程序）：通常具有很多短CPU区间</li>
<li>CPU约束程序（计算密集型程序）：通常具有少量长CPU区间</li>
</ul>
<p>可能出发进程调度的4种情况</p>
<ol>
<li>进程从运行状态切换到等待状态（如I/O请求、等待子进程终止）</li>
<li>进程从运行状态切换到就绪状态（如中断）</li>
<li>进程从阻塞状态切换到就绪状态（如I/O完成）</li>
<li>进程结束</li>
</ol>
<p>非抢占式/抢占式调度</p>
<ul>
<li>非抢占式调度：CPU一旦分配给某个进程，那么该进程会一直只用CPU直到进程终止或切换到阻塞状态</li>
<li>抢占式调度：需要额外的硬件支持</li>
</ul>
<p><strong>分派程序</strong>：用于将CPU的控制交给进程调度所选择的目标进程的</p>
<ul>
<li>切换上下文</li>
<li>切换到用户模式</li>
<li>跳转到用户程序的合适位置，以重新启动程序</li>
</ul>
<h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><ul>
<li>①CPU利用率<ul>
<li>CPU尽可能忙，40%（轻负荷）∼90%（重负荷）</li>
</ul>
</li>
<li>② 吞吐量<ul>
<li>单位时间内系统完成的进程数量</li>
</ul>
</li>
<li>③ 周转时间<ul>
<li>作业从提交到完成所经过的时间，包括后备队列延时、就绪队列延时、CPU执行时间、等待I/O时间</li>
<li>平均周转时间、平均加权周转时间</li>
</ul>
</li>
<li>④ 等待时间<ul>
<li>指进程在就绪队列中等待时间总和</li>
</ul>
</li>
<li>⑤ 响应时间<ul>
<li>指从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的时间间隔</li>
<li>响应时间短对与交互系统十分重要，是分时系统中进程调度算法的重要准则</li>
</ul>
</li>
<li><p>⑥ 截止时间</p>
<ul>
<li><p>开始截止时间/完成截止时间</p>
</li>
<li><p>实时系统中的重要准则</p>
</li>
</ul>
</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h4><p>思想</p>
<ul>
<li>从队列中选择最先进入的进程分配CPU</li>
<li>可用于作业调度</li>
<li>非抢占式</li>
</ul>
<p>优点</p>
<ul>
<li>简单、易于实现</li>
<li>实际系统中与其他算法结合使用</li>
</ul>
<p>缺点</p>
<ul>
<li>平均等待时间教程</li>
<li>所有短进程都在等待一个长进程释放CPU</li>
</ul>
<h4 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h4><p>思想</p>
<ul>
<li>从队列中选择执行时间最短的进程分配CPU</li>
<li>可用于作业调度</li>
<li>以作业的执行长短来计算优先级</li>
<li>抢占式/非抢占式</li>
</ul>
<p>优点</p>
<ul>
<li>平均等待时间最小</li>
</ul>
<p>缺点</p>
<ul>
<li>不利于长作业→饿死</li>
<li>需要准确知道下一个CPU执行取件时间（近似替代：用历史CPU执行区间华南时间进行预测）</li>
</ul>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>思想</p>
<ul>
<li>每个进程关联一个优先级，从队列中选择优先级最高的进程分配CPU</li>
<li>具有相同优先级的进程按照FCFS顺序调度</li>
<li>SJF是优先级调度的一个特例</li>
<li>抢占式/非抢占式</li>
</ul>
<p>优先级类型</p>
<ul>
<li>静态优先级</li>
<li>动态优先级</li>
</ul>
<p>缺点</p>
<ul>
<li>低优先级→饿死（Aging：逐渐提高系统中长时间等待的进程的优先级）</li>
</ul>
<h4 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h4><p>思想</p>
<ul>
<li>针对分时系统，将CPU时间划分成一个个的时间片，为就绪队列中的进程一次轮流分配一个时间片的CPU</li>
<li>抢占式</li>
</ul>
<p>实现</p>
<ul>
<li>FIFO队列+定时器</li>
</ul>
<p>性能</p>
<ul>
<li>就绪队列中有n个进程且时间片为q，每个进程必须等待的CPU时间不超过$(n-1)q$个时间单元</li>
<li>RR算法性能依赖于时间片的大小</li>
</ul>
<p><strong>RR调度算法</strong></p>
<ul>
<li>大多数现代操作系统的时间片一般为10～100ms，上下文切换的时间一般少于10𝛍s</li>
<li>时间片过大，RR→FCFS；时间片过小，上下文切换（系统开销）将过于频繁</li>
<li>周转时间依赖于时间片的大小</li>
</ul>
<h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><p>思想</p>
<ul>
<li>将就绪队列分成多个独立的队列，每个队列可采用不同的调度算法，队列之间一般采用优先级抢占调度</li>
</ul>
<p>实例</p>
<ul>
<li>前台进程队列（交互性的：RR）</li>
<li>后台队列（批处理：FCFS）</li>
</ul>
<h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>思想</p>
<ul>
<li>在多级队列的基础上，根据不同的CPU区间特点来区分进程，允许进程在队列之间移动：如果进程消耗过多CPU时间，就会被转移到优先级更低的队列，较低优先级队列中等待时间较长的进程将被转移到优先级更高的队列中（Aging）</li>
</ul>
<p>参数</p>
<ul>
<li>队列数量</li>
<li>每个队列的调度算法</li>
<li>向高优先级队列升级的确定方法</li>
<li>向低优先级队列降级的确定方法</li>
<li>确定进程在需要服务时应进入哪个队列的方法</li>
</ul>
<p>实例</p>
<ul>
<li>CPU区间在8ms以内的进程能够快速执行，CPU区间超过8ms但在24ms以内的也能够尽快完成</li>
</ul>
<h4 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h4><p>思想</p>
<ul>
<li>在优先级调度算法的基础上引入动态优先级</li>
</ul>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913144339432.png" alt="image-20200913144339432"></p>
<ul>
<li>如果等待时间相同，则要求服务时间越短，优先级越高，HRRNèSJF</li>
<li>如果要求服务时间相同，则等待时间越长，优先级越高，HRRNèFCFS</li>
<li>针对长进程，优先级随时间逐渐提高，防止饿死</li>
</ul>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><p>必要条件</p>
<ul>
<li>提供必要的信息<ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
</li>
<li>系统处理能力强<ul>
<li>足够的计算能力</li>
</ul>
</li>
<li>采用抢占式调度机制<ul>
<li>能满足硬实时任务对截止时间的要求</li>
</ul>
</li>
<li>具有快速切换机制<ul>
<li>对中断的快速响应能力</li>
<li>快速的任务分派能力</li>
</ul>
</li>
</ul>
<h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><p>多处理器调度方法</p>
<ul>
<li>非对称多处理方法</li>
<li>对称多处理方法</li>
</ul>
<p>负载均衡</p>
<ul>
<li>Push migration</li>
<li>Pull migration</li>
</ul>
<h2 id="第五章-进程同步"><a href="#第五章-进程同步" class="headerlink" title="第五章 进程同步"></a>第五章 进程同步</h2><h3 id="进程同步相关概念"><a href="#进程同步相关概念" class="headerlink" title="进程同步相关概念"></a>进程同步相关概念</h3><p><strong>进程同步</strong>：两个进程所表示事件的发生有着某种时序上的关系</p>
<p>多道系统中，由于进程间的资源共享或任务协作执行，使进程间可能存在两种形式的制约关系：</p>
<ul>
<li>间接制约/互斥关系</li>
<li>直接制约/同步关系</li>
</ul>
<p><strong>临界资源</strong>：一次仅允许一个进程使用的资源称为临界资源，包括：慢速设备，共享的变量、数据结构、缓冲区等</p>
<p>结论：多道系统中，为保证进程并发执行且结果确定，必须互斥使用临界资源</p>
<p><strong>临界区</strong>：进程中访问临界资源的代码段称为临界区</p>
<ul>
<li><p>为保证对临界资源的互斥使用，在使用临界资源之前应先申请、判断</p>
</li>
<li><p>一个访问临界资源的循环进程应为如下结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">While (<span class="literal">true</span>)</span><br><span class="line">&#123; </span><br><span class="line">    entry section; <span class="comment">//进入区</span></span><br><span class="line">	critical section; <span class="comment">//临界区</span></span><br><span class="line">	<span class="built_in">exit</span> section; <span class="comment">//退出区</span></span><br><span class="line">	remainder section; <span class="comment">//剩余区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步机制必须遵循的原则</p>
<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
</ul>
<p>解决进程互斥问题的软件方法：Peterson算法</p>
<ul>
<li>适用于两个进程在临界区域剩余区交替执行</li>
<li>两个进程P0和P1，分别用Pi、Pj（j=1-i）表示，变量turn表示哪个进程可以进入临界区，数组flag[] 表示哪个进程想要进入临界区，flag[i] = true 表示进程Pi已经就绪</li>
</ul>
<p>解决进程互斥问题的硬件方法</p>
<ul>
<li>许多现代计算机系统提供了特殊硬件指令以允许原子地（不可中断地）检查和修改字的内容或交换两个字的内容</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p><strong>信号量</strong>：除初始化外,仅能由同步原语对其进行操作的整型变量</p>
<p>同步原语：</p>
<ul>
<li><code>P()→wait()操作         //P（proheren，测试）</code></li>
<li><code>V()→signal()操作       //V（verhogen，增加）</code></li>
</ul>
<p>信号量机制目前已经发展成多种类型，主要有：整型、记录型和信号量集等</p>
<p>按用途，信号量可分为两大类</p>
<ul>
<li>二元信号量：用作互斥变量，初值为1</li>
<li>一般信号量：用于一般同步，初值为共享资源初始数量</li>
</ul>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>引入目的：为了克服整型信号量机制存在的“忙等”，引入记录型信号量</p>
<h4 id="信号量的物理意义"><a href="#信号量的物理意义" class="headerlink" title="信号量的物理意义"></a>信号量的物理意义</h4><p>wait()操作</p>
<ul>
<li>请求分配一个S代表的资源，执行S.value-1；</li>
<li>若S.value&lt;0，表示系统已无该类资源，申请者阻塞。此时， |S.value|表示该信号量上阻塞的进程数。</li>
</ul>
<p>signal() 操作</p>
<ul>
<li>进程释放一个S代表的资源，执行S.value+1；</li>
<li>若S.value&lt;=0，表示尚有进程因等待S代表的资源而处于阻塞状态，所以应唤醒其中之一。</li>
</ul>
<h4 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h4><ul>
<li><p>信号量用于进程互斥</p>
<ul>
<li>为每一个共享的临界资源设置一个互斥信号量，其初值为1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>；</span><br><span class="line">process_1（）</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	wait(mutex);</span><br><span class="line">	critical section;</span><br><span class="line">	signal(mutex);</span><br><span class="line">	remainder section;</span><br><span class="line">&#125;</span><br><span class="line">process_2（）</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	wait(mutex);</span><br><span class="line">	critical section;</span><br><span class="line">	signal(mutex);</span><br><span class="line">	remainder section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号量实现前趋关系</p>
<ul>
<li>定义n个信号量来描述有n条边的前趋图，初值都设为0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">P1() &#123; S1;signal(a); signal(b);&#125;</span><br><span class="line">P2() &#123; wait(a); S2;signal(c);signal(d);&#125;</span><br><span class="line">P3() &#123; wait(b); wait(c); S3; signal(e); &#125;</span><br><span class="line">P4() &#123; wait(d); wait(e); S4;&#125;</span><br><span class="line">main() &#123;</span><br><span class="line">	semaphore a, b, c, d, e;</span><br><span class="line">	a.value=<span class="number">0</span>; b.value=<span class="number">0</span>; c.value=<span class="number">0</span>; d.value=<span class="number">0</span>; e.value=<span class="number">0</span>;</span><br><span class="line">	parbegin</span><br><span class="line">	P1(); P2(); P3(); P4();</span><br><span class="line">	parend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913160929646.png" alt="image-20200913160929646"></p>
</li>
</ul>
<h4 id="死锁和饥饿"><a href="#死锁和饥饿" class="headerlink" title="死锁和饥饿"></a>死锁和饥饿</h4><p>死锁：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来触发，这种互为等待的状态称为死锁</p>
<p>饿死——无限期阻塞</p>
<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="生产者—消费者问题-有限缓冲问题"><a href="#生产者—消费者问题-有限缓冲问题" class="headerlink" title="生产者—消费者问题/有限缓冲问题"></a>生产者—消费者问题/有限缓冲问题</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913162557195.png" alt="image-20200913162557195"></p>
<p>问题</p>
<ul>
<li>一个包含N个单元的缓冲区，每个单元可存储一个数据项</li>
<li>生产者进程生产数据项放入缓冲区，用指针in定位，若无空缓冲区则阻塞</li>
<li>消费者进程从缓冲区取出数据项进行消费从而产生空单元，用指针out定位，若无包含数据项的缓冲区单元则阻塞</li>
</ul>
<p>分析</p>
<ul>
<li>使用互斥信号量mutex用于控制对缓冲区的互斥访问，初始化为1</li>
<li>一般信号量empty和full分别用以表示空缓冲区项和满缓冲区项的个数，初始分别为N和0</li>
</ul>
<h4 id="读者—写者问题"><a href="#读者—写者问题" class="headerlink" title="读者—写者问题"></a>读者—写者问题</h4><p>问题</p>
<ul>
<li>共享的数据集或文件可能在多个进程间被并发访问，因此可能有多个读者和写者对其进行操作</li>
<li>一般要求多个读者可以同时操作，而读者与写者、多个写者之间的操作应互斥</li>
</ul>
<p>分析</p>
<ul>
<li>为保证写者进程与其它进程互斥访问共享对象，设置互斥信号量db，初值为1</li>
<li>由于允许有多个读者，为了解当前读者数量，设置读者计数变量readercount，多个读者都对readercount进行操作，设置对其操作的互斥信号量mutex，初值为1</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p>问题</p>
<ul>
<li>假设有5个哲学家，所有的时间用来吃饭和思考，他们共坐一个圆桌上，每个人坐一把椅子，桌上有5根筷子</li>
<li>当某位哲学家感到饥饿时，他会试图拿桌上的筷子，每次只能拿一根，当同时有一双筷子时，他可以吃饭，吃饱后会放下两根筷子，开始思考</li>
<li>需要在多个进程之间分配多个资源且不会出现死锁和饿死</li>
</ul>
<p>分析</p>
<ul>
<li>每根共享的筷子都用一个信号量来表示：semaphore chopstick[i]</li>
</ul>
<h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><p>信号量机制存在下列3点不足：</p>
<ul>
<li>临界区、进入区和退出区都由用户编写</li>
<li>信号量操作原语分散在各程序代码中，由进程来执行，系统无法有效控制、管理</li>
<li>wait和signal操作的错误使用，编译程序和操作系统都无法发现、纠正，可导致死锁</li>
</ul>
<p>将所有进程对某一临界资源的同步操作都集中起来，构成所谓的“秘书”进程，凡要访问该临界资源的进程，都需先报告“秘书”，由其实现诸进程的同步，由此引入<strong>管程</strong></p>
<ul>
<li>管程是进程间同步的机制，它保证进程互斥地使用临界资源</li>
<li>管程的组成<ul>
<li>局部于管程的共享变量说明{数据结构}</li>
<li>对该数据结构进行操作的一组过程</li>
<li>局部于管程数据的初始化语句</li>
</ul>
</li>
</ul>
<h2 id="第六章-死锁"><a href="#第六章-死锁" class="headerlink" title="第六章 死锁"></a>第六章 死锁</h2><h3 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h3><p>系统模型</p>
<ul>
<li>系统中拥有多种类型的资源，如CPU周期、内存空间、文件、不同的I/O设备等</li>
<li>每种类型的资源都具有一定数量的实例，以供进程申请使用</li>
</ul>
<p>进程对资源的使用流程</p>
<ul>
<li>申请：如果申请不能立即被允许，申请进程则必须等待，直到获得该资源</li>
<li>使用：进程对资源进行操作</li>
<li>释放：进程释放资源</li>
</ul>
<p>死锁（deadlock）</p>
<ul>
<li>多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程将永远无法推进</li>
</ul>
<p>发生死锁的原因</p>
<ul>
<li>竞争资源</li>
<li>进程推进顺序不合理</li>
</ul>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913172019666.png" alt="image-20200913172019666"></p>
<h3 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h3><h4 id="死锁发生的必要条件"><a href="#死锁发生的必要条件" class="headerlink" title="死锁发生的必要条件"></a>死锁发生的必要条件</h4><ul>
<li>互斥</li>
<li>占有并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ul>
<h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><ul>
<li><p>资源分配图由一个节点集合V和一个边集合E组成，节点集合V可分为两种类型：进程集合$P={P1,P2,…, Pn}$ 和资源类型集合$R={R1, R2,…, Rm}$</p>
</li>
<li><p>E是边的集合，包括申请边和分配边两种类型。由进程Pi到资源类型Rj到的有向边次称为申请边，记为$Pi→ Rj$，表示进程$Pi$申请了资源类型$Rj$的一个实例，并等待该资源；由资源类型$Rj$到进程$Pi$的有向边称为分配边，记为$Rj→Pi$，表示资源类型$Rj$的一个实例已经分配给了进程$Pi$</p>
</li>
<li><p>在资源分配图中，用圆形表示进程$Pi$，矩形表示资源类型$Rj$</p>
</li>
<li><p>当进程申请资源类型的一个实例时，就在资源分配图中加入一条申请边，当该申请可以得到满足时，申请边就转换成分配边，当进程使用完并释放资源后，就删除分配边</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913172710343.png" alt="image-20200913172710343"></p>
<p><strong>如果资源分配图没有环，那么系统中一定不存在进程死锁</strong><br><strong>如果资源分配图中有环，则可能存在死锁</strong></p>
<ul>
<li>当每种资源类型只有1个实例时，如果图中存在环，则一定有进程死锁→此时，环检测可用于检测死锁的存在</li>
</ul>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200913173235573.png" alt="image-20200913173235573"></p>
<h4 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h4><p>确保系统不会发生死锁</p>
<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<p>无法确保系统不会发生死锁，提供处理机制</p>
<ul>
<li>死锁检测</li>
<li>死锁恢复</li>
</ul>
<p>忽视死锁</p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>破坏死锁发生的四个必要条件之一</p>
<h4 id="破坏占有并等待"><a href="#破坏占有并等待" class="headerlink" title="破坏占有并等待"></a>破坏占有并等待</h4><ul>
<li>方法一：每个进程执行之前必须申请并获得所需要的所有资源，后才能开始运行，在运行过程中进程只能释放资源不能申请资源</li>
<li>方法二：进程提出申请资源前必须释放已占有的一切资源</li>
<li>缺点：资源利用率很低，进程可能出现饥饿</li>
</ul>
<h4 id="破坏非抢占"><a href="#破坏非抢占" class="headerlink" title="破坏非抢占"></a>破坏非抢占</h4><ul>
<li>方法一：当进程Pi申请Rj类资源时，检查Rj中有无可用资源：有则分配给Pi ；否则将Pi占有的资源全部释放而进入等待状态（Pi等待其原占有的所有资源和申请的资源）</li>
<li>方法二：当进程Pi申请Rj类型的资源时检查Rj中有无可用资源：有则分配给Pi ；否则检查已获得Rj类资源的进程Pk，若Pk处于等待资源状态，则抢占Pk的Rj类资源并分配给Pi，若Pk不处于等待资源状态，则置Pi于等待资源状态（此时Pi原已占有的资源可能被抢占）</li>
</ul>
<h4 id="破环循环等待"><a href="#破环循环等待" class="headerlink" title="破环循环等待"></a>破环循环等待</h4><ul>
<li>采用资源顺序分配法可以破坏循环等待条件：给系统中的所有资源编号，即寻找一个函数<br>$F: R→N（R：资源类型集合，N：自然数集合）$</li>
<li>进程只能按递增顺序申请资源，即进程申请类型为Ri的资源后，当且仅当$F( Rj )&gt; F( Ri )$时，进程可以申请类型为$Rj$的资源</li>
<li>如果进程需要同一资源类型的多个实例，则必须对它们一起进行申请</li>
<li>当一个进程需要申请资源Rj时，必须先释放所有的资源$Ri (F(Ri)≥ F(Rj ))$</li>
</ul>
<h4 id="破坏互斥"><a href="#破坏互斥" class="headerlink" title="破坏互斥"></a>破坏互斥</h4><p>临界资源的访问就必须是互斥进行</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><h4 id="系统的安全状态"><a href="#系统的安全状态" class="headerlink" title="系统的安全状态"></a>系统的安全状态</h4><ul>
<li>进程序列$&lt; P1,P2,…, Pn &gt;$，如果对于每个$Pi， Pi$还需申请的资源数小于当前可用资源加上所有进程$Pj (其中j&lt;i) $所占有的资源，那么这一序列称为安全序列</li>
<li>如果存在一个安全序列，那么系统则处于安全状态，否则就处于不安全状态</li>
</ul>
<p>避免死锁</p>
<p>确保系统始终处于安全状态，当进程申请一个可用资源时，必须确保进行资源分配后，系统仍然处于安全状态，才能满足进程的申请</p>
<p>每种资源类型只有单个实例——资源分配图算法</p>
<p>每种资源类型只有多个实例——银行家算法</p>
<h4 id="资源分配图算法"><a href="#资源分配图算法" class="headerlink" title="资源分配图算法"></a>资源分配图算法</h4><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>每种资源类型只有单个实例</p>
<ul>
<li>资源分配图→等待（wait-for）图</li>
<li>环检测算法</li>
</ul>
<p>每种资源类型只有多个实例</p>
<ul>
<li>银行家算法类似的检测算法</li>
<li>能够找到一个进程的执行序列，就认为系统没有没有发生死锁</li>
</ul>
<p>调用检测算法</p>
<ul>
<li>死锁发生的频率</li>
<li>系统资源的使用状况</li>
<li>死锁检测也是系统开销</li>
</ul>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><ul>
<li>终止所有死锁进程</li>
<li>一次终止一个进程直到死锁循环被解除</li>
</ul>
<h4 id="资源抢占"><a href="#资源抢占" class="headerlink" title="资源抢占"></a>资源抢占</h4><ul>
<li>选择一个牺牲品：确定抢占顺序以使代价最小</li>
<li>回滚：抢占资源，将进程回滚到某个安全状态</li>
<li>饥饿：防止进程饥饿，让进程有限地被选为牺牲品</li>
</ul>
<h2 id="第七章-存储管理"><a href="#第七章-存储管理" class="headerlink" title="第七章 存储管理"></a>第七章 存储管理</h2><h3 id="基本概念和背景"><a href="#基本概念和背景" class="headerlink" title="基本概念和背景"></a>基本概念和背景</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li>主存储器简称内存或主存，是计算机系统中的主要部件</li>
<li>CPU从主存储器中取得指令和数据，并将其放入寄存器中，或反之</li>
<li>寄存器具有与CPU相同的处理速度，而主存的访问速度远低于CPU执行指令的速度</li>
<li>高速缓存是介于寄存器和存储器之间的存储器，用于备份主存中的常用数据，以减少CPU对主存的访问次数，协调CPU与主存之间的速度差异</li>
</ul>
<h4 id="存储管理的主要任务"><a href="#存储管理的主要任务" class="headerlink" title="存储管理的主要任务"></a>存储管理的主要任务</h4><ul>
<li>提供良好环境</li>
<li>方便用户，提高利用率</li>
<li>扩充主存储器</li>
</ul>
<h4 id="存储管理的功能"><a href="#存储管理的功能" class="headerlink" title="存储管理的功能"></a>存储管理的功能</h4><ul>
<li>主存空间的分配与管理</li>
<li>地址转换与重定位</li>
<li>存储保护与共享</li>
<li>存储扩充</li>
</ul>
<h4 id="相关概念和术语"><a href="#相关概念和术语" class="headerlink" title="相关概念和术语"></a>相关概念和术语</h4><ul>
<li>逻辑地址/ 相对地址：CPU所生成的地址，又称为虚拟地址</li>
<li>物理地址/ 绝对地址：内存单元所看到的地址（加载到内存地址寄存器中的地址）</li>
<li>逻辑地址空间：由程序所生成的所有逻辑地址的集合称为逻辑地址空间</li>
<li>物理地址空间：与逻辑地址对应的所有物理地址的集合称为物理地址空间</li>
<li>重定位：从逻辑地址（虚拟地址）到物理地址的映射称为重定位，由内存管理单元（MMU完成</li>
<li>重定位寄存器：基址寄存器、限长寄存器</li>
<li>绑定：从一个地址空间到另一个地址空间的映射</li>
</ul>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>内存空间的保护是通过CPU硬件对用户模式所产生的每一个地址与寄存器地址进行<strong>比较</strong>来实现的</p>
<h4 id="用户处理过程"><a href="#用户处理过程" class="headerlink" title="用户处理过程"></a>用户处理过程</h4><ul>
<li>重定位<ul>
<li>静态重定位：程序装入主存之前由编译/链接程序完成重定位，入主存可立即执行</li>
<li>动态重定位：程序入主存之前不进行重定位，入主后存执行到与地址相关项时，再进行重定位</li>
</ul>
</li>
<li>装入<ul>
<li>绝对装入：事先已经知道用户程序入主存后的位置，编译程序在编译时就完成<strong>静态重定位</strong>，即将相对地址修改为绝对地址，装入程序按照装入模块中的地址，将程序和数据装入内存</li>
<li>可重定位装入：多道环境下，编译程序不能预知用户程序入主存后的位置，因此编译后的目标模块的起始地址一般设为从0开始。可重定位装入程序根据内存使用情况，将装入模块进行<strong>静态重定位</strong>后装入内存</li>
<li>动态运行时装入：装入程序将装入模块装入内存后，不将装入模块中的逻辑地址修改为物理地址，而是在执行时在重定位寄存器的辅助下再进行<strong>动态重定位</strong></li>
</ul>
</li>
<li>链接<ul>
<li>静态链接<ul>
<li>程序运行之前，现将各目标模块以及所需库函数链接成一个完整的装入模块</li>
<li>要解决的问题<ul>
<li>修改相对地址</li>
<li>将外部调用符号变换为相对地址</li>
</ul>
</li>
</ul>
</li>
<li>装入时动态链接<ul>
<li>将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式</li>
<li>优点<ul>
<li>便于修改和更新目标模块</li>
<li>实现对某些目标模块的共享</li>
</ul>
</li>
</ul>
</li>
<li>运行时动态链接<ul>
<li>将对某些目标模块的链接推迟到程序执行时才进行</li>
<li>有些目标模块（如错误处理）如果在执行过程中未被用到甚至不会被装入内存和进行链接</li>
<li>不仅能加快装入过程，而且还能节省内存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="动态链接与共享库"><a href="#动态链接与共享库" class="headerlink" title="动态链接与共享库"></a>动态链接与共享库</h4><p>动态链接库</p>
<ul>
<li>如果有动态链接，进程的二进制镜像中对每个库程序的引用都有一个存根</li>
<li>存根（stub）——用来指出如何定位适当的内存存储库程序的一小段代码</li>
</ul>
<p>语言子程序库</p>
<ul>
<li>调用语言子程序库将执行引用它的存根，首先检查所需的子程序是否已经在内存中，如果不在，就将其装入内存，存根将会由子程序地址取代，并开始执行子程序</li>
<li>后续再执行该子程序时，就可以直接执行而不需要产生额外的动态链接开销，因此使用语言库的所有进程只需要一个库代码副本</li>
</ul>
<p>共享库</p>
<ul>
<li>程序和库包含版本信息</li>
<li>较大的改动才修改版本号</li>
<li>多个版本的库都可以装入内存</li>
<li>程序根据版本决定使用哪个库</li>
</ul>
<h3 id="连续分配存储管理"><a href="#连续分配存储管理" class="headerlink" title="连续分配存储管理"></a>连续分配存储管理</h3><h4 id="单一连续分配（单用户单任务OS）"><a href="#单一连续分配（单用户单任务OS）" class="headerlink" title="单一连续分配（单用户单任务OS）"></a>单一连续分配（单用户单任务OS）</h4><ul>
<li>内存分为：OS系统区，单个用户进程区</li>
</ul>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ul>
<li>分区划分<ul>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ul>
</li>
<li>内存分配</li>
<li>内碎片（Internal Fragmentation）</li>
</ul>
<h4 id="动态分区分配-可变分区分配"><a href="#动态分区分配-可变分区分配" class="headerlink" title="动态分区分配/可变分区分配"></a>动态分区分配/可变分区分配</h4><ul>
<li>主存分为操作系统区域和用户进程区域</li>
<li><p>分区说明表：记录可用分区和已分配分区</p>
</li>
<li><p>存储保护</p>
<ul>
<li>重定位寄存器（包括基址寄存器和限长寄存）：对内存的访问进行保护</li>
<li>基址寄存器：记录进程在内存中起始的物理地址</li>
<li>限长寄存器：记录进程逻辑地址长度</li>
</ul>
</li>
<li><p>为进程选择合适的可用分区：动态分区分配算法</p>
</li>
</ul>
<h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><ul>
<li>首次适应（First Fit）：从头开始找到的第一个足够大的分区</li>
<li>循环首次适应（Next Fit）：首次适应的变种，从上次找到的位置继续往下找，找到的第一个足够大的分区</li>
<li>最佳适应（Best Fit）：搜索所有可用分区，找到的足够大但却最小的分区</li>
<li>最差适应（Worst Fit）：搜索所有可用分区，找到的最大的分区</li>
</ul>
<p><strong>首次适应和最佳适应算法在执行时间和空间利用方面都优于最差适应算法，首次适应算法执行最快</strong></p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><ul>
<li>外碎片：内存中小块的空闲分区，无法单独满足任何一个进程的需求，但这些非连续的空闲空间之和能够满足请求</li>
<li>内碎片：固定分区分配方式中存在的，已经分配给进程，但进程却不会使用的那一部分空闲空间</li>
</ul>
<p><strong>紧缩</strong></p>
<ul>
<li>目的：移动内存内容，将所有空闲空间合并成一整块</li>
<li>前提：动态重定位</li>
</ul>
<p><strong>离散分配内存</strong></p>
<ul>
<li>分页分配</li>
<li>分段分配</li>
<li>段页式分配</li>
</ul>
<h3 id="覆盖和交换技术"><a href="#覆盖和交换技术" class="headerlink" title="覆盖和交换技术"></a>覆盖和交换技术</h3><p><strong>解决内存空间的不足，用时间换空间</strong></p>
<ul>
<li>多道批处理系统中，较小空间中运行较大程序时遇到的矛盾</li>
<li>覆盖技术主要用于早期操作系统</li>
<li>交换技术广泛用于小型分时系统中，交换技术也是后来虚存管理的基础</li>
<li>相同点<ul>
<li>进程的程序和数据主要存放在外存（盘交换区），当前需要执行的部分存放在内存，内外存之间进行信息交换</li>
</ul>
</li>
<li>不同点<ul>
<li>覆盖：进程内部区域的替换</li>
<li>交换：进程之间的替换</li>
</ul>
</li>
</ul>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><ul>
<li>把程序划分为若干功能上相对独立的程序段，按照自身逻辑结构将那些不会同时执行的程序段共享同一块内存区域</li>
<li>程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段</li>
</ul>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ul>
<li>当内存空间紧张时，系统将内存中某些进程暂时移到外存（盘交换区），把外存中某些进程换入内存中，替换移出进程原来的内存空间</li>
<li>这种技术是进程在内存与外存之间的动态调度，多用于分时系统中</li>
<li>中级调度：采用交换技术</li>
</ul>
<h3 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h3><h4 id="分页思想"><a href="#分页思想" class="headerlink" title="分页思想"></a>分页思想</h4><ul>
<li>内存物理地址空间按2n 等分成页框/帧，并从0连续编号：0,1,2,…</li>
<li>作业的逻辑地址空间按页框/帧大小等分成页，并从0连续编号：0,1,2,…</li>
<li>作业逻辑地址表示为：v=(p,d)</li>
<li>作业连续的页，可以分配不连续的页框/帧</li>
<li>系统设置页表PMT保存作业各页入内存后的情况，包含页号、页框号</li>
<li>设置一个页表地址寄存器，保存当前执行进程页表的起始地址和页表的长度</li>
</ul>
<h4 id="直接地址变换"><a href="#直接地址变换" class="headerlink" title="直接地址变换"></a>直接地址变换</h4><ul>
<li>借助页表、页表寄存器完成作业的逻辑地址（虚地址）到内存物理地址的变换</li>
<li><p>页表基址寄存器（PTBR） 页表长度寄存器（PRLR）</p>
</li>
<li><p>从虚地址转换为物理地址，然后再完成地址访问，共访问几次主存？效率为多少？</p>
</li>
</ul>
<h4 id="具有快表的地址变换"><a href="#具有快表的地址变换" class="headerlink" title="具有快表的地址变换"></a>具有快表的地址变换</h4><p>增设若干具有并行查询能力的特殊高速缓冲寄存器（联想寄存器/快表），保存当前执行进程的部分页表</p>
<p><strong>程序的局部性特征</strong></p>
<ul>
<li>遵循结构化设计的程序具有时间局部性和空间局部性两个特征</li>
<li>时间局部性：<ul>
<li>刚被访问的主存单元，不久会再次被访问：循环操作</li>
</ul>
</li>
<li>空间局部性：<ul>
<li>刚被访问的主存单元，其临近单元不久会被访问：程序的顺序执行</li>
</ul>
</li>
</ul>
<p><strong>有效访问时间</strong></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914135746955.png" alt="image-20200914135746955"></p>
<h4 id="共享页"><a href="#共享页" class="headerlink" title="共享页"></a>共享页</h4><ul>
<li>分页管理的优点之一就是可以共享公共代码</li>
<li>多用户的分时系统中，对于一个公共应用程序，如果要为每一个用户在内存中存储一份代码副本将极大地浪费空间</li>
<li>可以将可重入代码设置为共享（e.g. ed 1、ed 2、ed 3），每个进程只需要拥有自己独立的数据页（e.g. data 1、data 2、data 3）</li>
<li>可重入代码（reentrant code）：或称为纯代码（pure code），是不能自我进行修改的代码，不会在执行期间发生改变，代码中不包含任何变量</li>
</ul>
<h4 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h4><p>思想</p>
<ul>
<li>页表再按页框大小分页，并从0连续编号：0号页表,1号页表,2号页表,…</li>
<li>为所有页表再建立一张页表（外层页表），每个页表项记录页表页面的物理页框号</li>
<li>设置外层页表寄存器，存放外层页表的起始地址</li>
<li>逻辑地址表示：v=(p1,p2,d)</li>
</ul>
<h4 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h4><p>为每一个物理页框设置一个条目，并记录该物理页框所分配的进程ID和对应的逻辑页</p>
<p>优点：节省空间</p>
<p>缺点：增加页表查询时间；难以共享页面</p>
<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><p>引入分段管理</p>
<p>段：一组逻辑信息的集合。如：主程序段、子程序段、数据段、堆栈段等</p>
<p>引入原因</p>
<ul>
<li>方便编程</li>
<li>分段共享</li>
<li>分段保护</li>
<li>动态连接</li>
<li>动态增长</li>
</ul>
<h4 id="分段思想"><a href="#分段思想" class="headerlink" title="分段思想"></a>分段思想</h4><ul>
<li>作业的逻辑地址空间分段，每个段有自己的段名，并从0连续编号：0,1,2,…</li>
<li>装入程序将分段装入时，为每一个分段分配一段号</li>
<li>作业逻辑地址表示：v=(s,d)</li>
<li>以段为单位分配主存，每一分段分配连续的分区</li>
<li>系统设置段保存作业各段入内存后的情况：主要有包括段号、段长、主存起址</li>
<li>设置一个段表地址寄存器，保存当前执行进程段表的起始地址和长度</li>
</ul>
<h4 id="分段的保护和共享"><a href="#分段的保护和共享" class="headerlink" title="分段的保护和共享"></a>分段的保护和共享</h4><p><strong>段的保护</strong></p>
<ul>
<li>段表基址寄存器STBR和段表长度寄存器STLR</li>
<li>与段相关的保护位：只读、只写、只执行</li>
<li>与段相关的Validation位：为0表示不合法段</li>
</ul>
<p><strong>段的共享</strong></p>
<ul>
<li>设置共享段表</li>
<li>第一个请求使用共享段的进程申请内存分区，调入，修改共享段表内容</li>
<li>后续进程使用共享段，在本进程段表填入共享段物理地址；在共享段表中增加表目，将共享段计数count加1</li>
<li>回收执行count-1</li>
<li>count=0时撤销该共享段</li>
</ul>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914140501432.png" alt="image-20200914140501432"></p>
<h3 id="分页与分段存储管理比较"><a href="#分页与分段存储管理比较" class="headerlink" title="分页与分段存储管理比较"></a>分页与分段存储管理比较</h3><ol>
<li>页是信息的<strong>物理单位</strong>，为实现离散存储，提高内存利用率而引入；段是信息的<strong>逻辑单位</strong>，为满足用户要求而引入</li>
<li>页的<strong>大小固定</strong>且由<strong>系统确定</strong>；而<strong>段长不定</strong>，<strong>取决于用户程序</strong>，并在编译时划分</li>
<li>分页的作业地址空间是<strong>一维</strong>的；分段的作业地址空间是<strong>二维</strong>的</li>
</ol>
<h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul>
<li>内存物理地址空间等分成页框，并从0连续编号</li>
<li>作业的逻辑地址分段</li>
<li>作业各段按页框大小等分成页，并从0连续编号</li>
<li>作业逻辑地址表示：v=(s, p, d)</li>
<li>作业各段连续的页，可以分配不连续的页框</li>
<li>系统为每个作业设置一个段表，每个分段再设置一个页表，分别保存作业各段及每段各页入内存后的情况<ul>
<li>段表包括段号、该段页表起址、该段页表长度</li>
<li>页表包括页号、页框号 </li>
</ul>
</li>
<li>设置一个段表地址寄存器，保存当前执行进程段表的起始地址和段表的长度</li>
</ul>
<p>示例</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914140832626.png" alt="image-20200914140832626"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914140727368.png" alt="image-20200914140727368"></p>
<h2 id="第八章-虚存管理"><a href="#第八章-虚存管理" class="headerlink" title="第八章 虚存管理"></a>第八章 虚存管理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>实存管理特征</p>
<ul>
<li>一次性：作业必须一次性地全部装入内存后才能开始运行</li>
<li>驻留性：作业装入内存后，整个作业都一直驻留在内存中</li>
</ul>
<p>程序运行时存在局部性原理</p>
<ul>
<li>很多情况下，不需要将整个程序放到内存中<ul>
<li>处理异常错误条件的代码</li>
<li>数组、链表和表通常都分配了比实际所需更多的内存</li>
<li>程序中很少使用的部分选项或功能</li>
</ul>
</li>
</ul>
<p><strong>虚拟存储器</strong></p>
<p>虚拟存储器（是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</p>
<ul>
<li>逻辑内存和物理内存分离</li>
<li>执行程序只有部分在内存中</li>
<li>逻辑地址空间远大于物理地址空间</li>
</ul>
<p><strong>虚存管理特征</strong></p>
<ul>
<li><p>离散性</p>
</li>
<li><p>多次性</p>
</li>
<li>对换性</li>
<li>虚拟性</li>
</ul>
<h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><h4 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h4><ul>
<li>在分页系统的基础上增加了请求调页功能和页面置换功能</li>
<li>整个用户程序驻留在磁盘（二级存储）上，只装入少量页面入内存即可启动运行</li>
<li>程序运行中，由调页程序（pager）根据需要将单个页面从磁盘调入内存， 将不需要的页面换出到磁盘上</li>
<li>置换时以页为单位</li>
<li>硬件支持<ul>
<li>请求页表机制</li>
<li>缺页中断机构</li>
<li>地址变换机构</li>
</ul>
</li>
</ul>
<h4 id="请求页表机制"><a href="#请求页表机制" class="headerlink" title="请求页表机制"></a>请求页表机制</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914145729236.png" alt="image-20200914145729236"></p>
<ul>
<li>状态位P（有效-无效位）：用于指示该页是否已经调入内存</li>
<li>访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，以供置换算法在选择置换页面时参考</li>
<li>修改位M（脏位）：标识该页在调入内存后是否被修改过</li>
<li>外存地址：该页在外存上的地址，一般指物理块号</li>
</ul>
<h4 id="缺页中断机制"><a href="#缺页中断机制" class="headerlink" title="缺页中断机制"></a>缺页中断机制</h4><p>缺页中断处理过程</p>
<ol>
<li>访问进程页表，查看访问页是否合法</li>
<li>如果是非法访问，则终止进程访问；如果页面访问合法，但该页不在内存中，则需要调入</li>
<li>在物理内存中找到一个空闲页框（free frame）</li>
<li>调度磁盘操作，将失效页从备用存储（磁盘）中装入空闲页框</li>
<li>重置页表，修改页面信息</li>
<li>重启因缺页而中断的指令</li>
</ol>
<h3 id="缺页中断与一般中断的区别"><a href="#缺页中断与一般中断的区别" class="headerlink" title="缺页中断与一般中断的区别"></a>缺页中断与一般中断的区别</h3><ul>
<li>是在指令执行期间，发现指令/数据不在主存时产生并处理</li>
<li>一条指令在执行期间，可能会产生多次缺页中断，要求系统能保存多次中断的状态</li>
</ul>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>具有快表的地址变换过程</p>
<ol>
<li><p>存储保护检查：页号&gt;页表长度？</p>
<ul>
<li><p>是，越界中断</p>
</li>
<li><p>否则2</p>
</li>
</ul>
</li>
<li><p>查快表</p>
<ul>
<li>找到，修改访问位对于写操作置修改位，形成物理地址访问</li>
<li>若未找到，查页表状态位</li>
<li>在主存，将表目写入快表</li>
<li>否则，缺页中断</li>
</ul>
</li>
</ol>
<h4 id="请求分页性能分析"><a href="#请求分页性能分析" class="headerlink" title="请求分页性能分析"></a>请求分页性能分析</h4><p>有效访问时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设缺页率为p（<span class="number">0</span> ≤ p ≤ <span class="number">1</span>）</span><br><span class="line"><span class="keyword">if</span> p = <span class="number">0</span> 无缺页，实存管理</span><br><span class="line"><span class="keyword">if</span> p = <span class="number">1</span> 每一次页面访问都产生缺页，纯请求分页（Pure demand paging）</span><br><span class="line">EAT = (<span class="number">1</span> – p) × memory access <span class="comment">//内存访问时间</span></span><br><span class="line">	+ p× page fault time (page fault overhead <span class="comment">//缺页中断处理时间</span></span><br><span class="line">		+ swap page out (optional) <span class="comment">//页面换出时间（可选）</span></span><br><span class="line">		+ swap page in <span class="comment">//页面换入时间</span></span><br><span class="line">		+ restart overhead) <span class="comment">// 重启指令开销</span></span><br></pre></td></tr></table></figure>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="基本页面置换"><a href="#基本页面置换" class="headerlink" title="基本页面置换"></a>基本页面置换</h4><ul>
<li>查找所需页在磁盘上的位置</li>
<li>查找一个空闲的页框：<ul>
<li>如果有空闲页框，那么就使用它</li>
<li>如果有没有空闲页框，就使用页面置换算法以选择一个“牺牲”页框（victim frame）</li>
<li>将“牺牲”页框的内容写到磁盘上，修改页表和页框表</li>
</ul>
</li>
<li>将所需页读入空闲页框，修改相应的页表和页框表</li>
<li>重启用户进程</li>
</ul>
<p><strong>修改位（脏位）：减少页面置换开销，只需要将修改过的页面写回磁盘</strong></p>
<p><strong>请求分页的实现：页框分配算法和页面置换算法</strong></p>
<h4 id="页面置换算法-1"><a href="#页面置换算法-1" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul>
<li>算法评价指标：缺页率</li>
<li>算法评估方法：针对特定的内存访问序列，运行置换算法，并计算出缺页次数</li>
<li>后面的算法评估中，统一采用访问串：</li>
<li>缺页次数会随着页框数的增加而降低</li>
</ul>
<h4 id="先进先出（FIFO）页面置换算法"><a href="#先进先出（FIFO）页面置换算法" class="headerlink" title="先进先出（FIFO）页面置换算法"></a>先进先出（FIFO）页面置换算法</h4><p>FIFO算法总是淘汰最早进入内存的页面，即选择在内存中驻留时间最久的页面进行置换</p>
<p>Belady奇异：对于所有的页面置换算法，缺页率可能会随着所分配的页框增加而增加，而原本希望通过增加内存改善性能</p>
<h4 id="最佳（Optimal）置换算法"><a href="#最佳（Optimal）置换算法" class="headerlink" title="最佳（Optimal）置换算法"></a>最佳（Optimal）置换算法</h4><p>最佳置换算法将置换未来最长时间内不会访问的页面</p>
<h4 id="最近最少使用（LRU）页面置换算法"><a href="#最近最少使用（LRU）页面置换算法" class="headerlink" title="最近最少使用（LRU）页面置换算法"></a>最近最少使用（LRU）页面置换算法</h4><p>最近最少使用（LRU）页面置换算法选择过去最长时间没有访问的页面进行置换</p>
<p>LRU算法实现</p>
<ul>
<li>计数器：为每一个页表项关联一个使用时间域</li>
<li>栈：页码栈，每当访问一个页面，就将该页面从栈中删除并从顶上重新压入，栈底总是LRU页</li>
</ul>
<h4 id="近似LRU页面置换算法"><a href="#近似LRU页面置换算法" class="headerlink" title="近似LRU页面置换算法"></a>近似LRU页面置换算法</h4><h5 id="附加访问位算法"><a href="#附加访问位算法" class="headerlink" title="附加访问位算法"></a>附加访问位算法</h5><ul>
<li>为页表中的每一页保留一个8位的字节</li>
<li>在规定的时间间隔（如每隔100ms）内，时钟定时器产生中断，OS将页面的访问位转移到8位字节的高位，他位均向右移一位，最低位丢弃，这个8位字节记录了该页面在最近的8个时间间隔内的使用情况</li>
<li>选择值最小的页面置换，相等情况下按照FIFO算法执行</li>
</ul>
<h5 id="二次机会算法（Clock置换算法）"><a href="#二次机会算法（Clock置换算法）" class="headerlink" title="二次机会算法（Clock置换算法）"></a>二次机会算法（Clock置换算法）</h5><ul>
<li>页表中的每一页有一个访问位（页面被访问后将其置为1）</li>
<li>按照FIFO的方式选择置换页，如果该页的访问位为1，则给予第二次机会，将其访问位置为0</li>
</ul>
<h4 id="计数页面置换算法"><a href="#计数页面置换算法" class="headerlink" title="计数页面置换算法"></a>计数页面置换算法</h4><p>为页表中的每一页保留一个用于记录其访问次数的计数器</p>
<h5 id="最不经常使用（LFU）页面置换算法"><a href="#最不经常使用（LFU）页面置换算法" class="headerlink" title="最不经常使用（LFU）页面置换算法"></a>最不经常使用（LFU）页面置换算法</h5><ul>
<li>置换计数最小的页面：活动页应该有更多的访问次数</li>
<li><p>问题：一个页面在进程开始时使用频繁，但后面不再使用</p>
</li>
<li><p>解决方法：定期将次数寄存器移位，形成指数衰减的平均使用次数</p>
</li>
</ul>
<h5 id="最常使用（MFU）页面置换算法"><a href="#最常使用（MFU）页面置换算法" class="headerlink" title="最常使用（MFU）页面置换算法"></a>最常使用（MFU）页面置换算法</h5><p>置换计数最大的页面：具有最小次数的页可能刚刚调入内存</p>
<h3 id="页框分配算法"><a href="#页框分配算法" class="headerlink" title="页框分配算法"></a>页框分配算法</h3><p>每个运行的进程至少需要一个最小数量的页框集</p>
<ul>
<li>性能影响：$进程可用页框↓→进程执行性能↓$</li>
<li>计算机结构：一条指令中包含了对于多个页面的访问</li>
</ul>
<p><strong>固定分配算法</strong></p>
<ul>
<li><p>平均分配：性能影响：$进程可用页框↓→进程执行性能↓$</p>
</li>
<li><p>按比例分配：根据进程大小按比例分配</p>
</li>
</ul>
<p><strong>基于优先级分配算法</strong></p>
<ul>
<li>按照进程的优先级成比例地给进程分配页框</li>
<li>进程发生缺页中断时<ul>
<li>选择自己的页框进行页面置换</li>
<li>选择优先级更低的进程的页框进行置换</li>
</ul>
</li>
</ul>
<h4 id="全局分配与局部分配"><a href="#全局分配与局部分配" class="headerlink" title="全局分配与局部分配"></a>全局分配与局部分配</h4><p><strong>全局置换</strong></p>
<ul>
<li>允许进程从所有页框集合中选择一个进行置换，不管该页框知否已经分配给其他进程</li>
<li>e.g. 允许高优先级的进程从低优先级进程中选择页框进行置换</li>
<li>全局置换算法无法控制单个进程的缺页率，但系统会取得更好的系统吞吐量</li>
</ul>
<p><strong>局部置换</strong></p>
<ul>
<li>分配给每个进程的页框数量不变</li>
<li>每个进程仅仅从自己所分配的页框中进行页面置换</li>
</ul>
<h3 id="请求分页系统性能分析"><a href="#请求分页系统性能分析" class="headerlink" title="请求分页系统性能分析"></a>请求分页系统性能分析</h3><h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><p>CPU的利用率会随着道数的增加而提高，直到达到最大值，达到最大值后继续提高道数，CPU的利用率将不再提高，反而急剧下降，这就是<strong>“系统抖动”</strong><br><strong>为了提升CPU利用率，则需要减少道数，消除抖动</strong></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914152128036.png" alt="image-20200914152128036"></p>
<p><strong>抖动产生的原因</strong></p>
<p>同时在系统中运行的进程太多，分配给每个进程的页框太少，不能满足进程正常运行的基本要求</p>
<h4 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h4><p>局部模型</p>
<ul>
<li>局部时一个经常使用页的集合</li>
<li>一个程序通常由多个不同局部组成，其中可能重叠</li>
</ul>
<p><strong>工作集模型</strong></p>
<p>工作集：进程在某段时间内实际访问页的集合</p>
<p>设进程在$t-Δ$ 到$t$ 时间段内访问页的工作集记为：$WS(t, Δ) （Δ为工作集窗口尺寸）$，则$WSS=| WS(t, Δ)|$为工作集中包含的页面数</p>
<p>工作集WS是二元函数</p>
<ul>
<li>WS是t 的函数，随时间不同，工作集不同</li>
<li>WS是Δ 的非降函数</li>
</ul>
<p>若Δ 过大，甚至将整个作业地址空间包含在内，则失去虚存意义； Δ 过小，会导致频繁缺页</p>
<h3 id="预防抖动"><a href="#预防抖动" class="headerlink" title="预防抖动"></a>预防抖动</h3><ul>
<li>采取局部置换策略</li>
<li>将工作集算法融入作业调度</li>
<li>利用“L=S“准则调节缺页率</li>
<li>选择暂停的进程</li>
</ul>
<h2 id="第九章-I-O系统"><a href="#第九章-I-O系统" class="headerlink" title="第九章 I/O系统"></a>第九章 I/O系统</h2><h3 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h3><h4 id="I-O系统的基本功能"><a href="#I-O系统的基本功能" class="headerlink" title="I/O系统的基本功能"></a>I/O系统的基本功能</h4><ul>
<li>隐藏物理设备的细节</li>
<li>与设备的无关性</li>
<li>提高处理机和I/O设备的利用率</li>
<li>对I/O设备进行控制</li>
<li>确保对设备的正确共享</li>
<li>错误处理</li>
</ul>
<p>第1、2项功能：方便用户使用I/O设备</p>
<p>第3、4项功能：提高CPU和I/O设备的利用率</p>
<p>第5、6项功能：为用户共享提供方便并保证系统正确运行</p>
<h4 id="I-O系统的层次结构"><a href="#I-O系统的层次结构" class="headerlink" title="I/O系统的层次结构"></a>I/O系统的层次结构</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914195730141.png" alt="image-20200914195730141"></p>
<ul>
<li>中断处理程序：直接与I/O硬件进行交互</li>
<li>设备驱动程序：进程和设备控制器之间的通信程序，实现上次抽象I/O请求到I/O设备具体命令和参数的转换，由设备制造厂商提供</li>
<li>设备独立性软件：现代OS中的I/O系统基本上都实现了与设备无关性；I/O软件独立于具体使用的物理设备，包括设备命名、设备分配、数据缓冲和数据高速缓冲等软件</li>
</ul>
<h4 id="I-O系统接口"><a href="#I-O系统接口" class="headerlink" title="I/O系统接口"></a>I/O系统接口</h4><ul>
<li>块设备接口<ul>
<li>块设备：数据的存取和传输都是以数据块为单位的，磁盘设备的I/O经常采用DMA方式</li>
<li>隐藏了磁盘的二维结构：将磁盘上所有扇区从0开始连续编号</li>
<li>将抽象命令映射为低层操作</li>
</ul>
</li>
<li>流设备接口<ul>
<li>字符设备：数据的存取和传输都是以字符为单位的，字符设备I/O常采用中断驱动方式</li>
<li>get和put操作：内存与字符缓冲区之间的字符读取</li>
<li>in-control指令：通用指令统一处理不同设备类型的指令</li>
</ul>
</li>
<li>网络通信接口</li>
</ul>
<h4 id="I-O设备设备类型"><a href="#I-O设备设备类型" class="headerlink" title="I/O设备设备类型"></a>I/O设备设备类型</h4><p>按设备中数据传输单位分</p>
<ul>
<li>块设备</li>
<li>字符设备</li>
</ul>
<p>按资源分配角度分</p>
<ul>
<li>独占设备</li>
<li>共享设备</li>
<li>虚拟设备</li>
</ul>
<p>按使用特性分</p>
<ul>
<li>输入设备</li>
<li>输出设备</li>
<li>交互式设备</li>
</ul>
<p>按传输速率分</p>
<ul>
<li>低速设备</li>
<li>中速设备</li>
<li>高速设备</li>
</ul>
<h4 id="设备与控制器之间的接口"><a href="#设备与控制器之间的接口" class="headerlink" title="设备与控制器之间的接口"></a>设备与控制器之间的接口</h4><p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914200517585.png" alt="image-20200914200517585"></p>
<ul>
<li>数据信号线：用于在设备与设备控制器之间传输数据</li>
<li>控制信号线：设备控制器向I/O设备发送控制信号时的通路</li>
<li>状态信号线：传送指示设备当前状态的信号</li>
</ul>
<h4 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h4><p>I/O设备一般由机械和电子部分组成，电子部分称作设备控制器</p>
<p><strong>基本功能</strong></p>
<ul>
<li>接收和识别命令：控制器中有多个寄存器和命令译码器等</li>
<li>数据交换：设备控制器与CPU之间通过数据总线实现，设备控制器与设备之间通过数据寄存器实现</li>
<li>标识和报告设备的状态：设备控制器中设置了状态寄存器供CPU读取</li>
<li>地址识别：设备控制器必须能够识别所控制的每个设备的地址，配置了地址译码器</li>
<li>数据缓冲区</li>
<li>差错控制</li>
</ul>
<p><strong>设备控制器组成</strong></p>
<ul>
<li>设备控制器与CPU接口</li>
<li>I/O逻辑</li>
<li>设备控制器与设备接口</li>
</ul>
<h4 id="I-O系统结构"><a href="#I-O系统结构" class="headerlink" title="I/O系统结构"></a>I/O系统结构</h4><p>总线型结构</p>
<ul>
<li>总线：是一组线和一组严格定义的可以描述在线上传输信息的协议</li>
<li>一般采用轮询（polling）I/O（或称为程序控制I/O）方式</li>
</ul>
<p>通道型结构</p>
<ul>
<li>I/O通道：是一种特殊的处理机，它控制设备与内存直接进行数据交换</li>
<li>I/O通道与一般的处理机的区别：<ul>
<li>通道的指令类型单一，主要局限于与I/O操作有关的指令</li>
<li>通道没有自己的内存，是与CPU共享内存</li>
</ul>
</li>
<li>通道类型<ul>
<li>字节多路通道</li>
<li>数组选择通道</li>
<li>数组多路通道</li>
</ul>
</li>
</ul>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><ul>
<li>程序直接控制方式</li>
<li>中断驱动I/O控制方式</li>
<li>DMA控制方式</li>
<li>通道控制方式</li>
</ul>
<h4 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h4><p>程序直接控制I/O方式中CPU直接控制I/O操作的过程, 包括测试设备状态、发送读/写命令和传送数据</p>
<p>缺点：CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中</p>
<h4 id="中断驱动I-O控制方式（常用于字符设备的I-O控制）"><a href="#中断驱动I-O控制方式（常用于字符设备的I-O控制）" class="headerlink" title="中断驱动I/O控制方式（常用于字符设备的I/O控制）"></a>中断驱动I/O控制方式（常用于字符设备的I/O控制）</h4><p>从I/O控制器的角度来看</p>
<p>对于输入, I/O控制器接收到CPU的读命令, 然后开始从相关的设备读数据；一旦数据进入到控制器的数据寄存器, I/O控制器通过中断信号线向CPU发一个中断信号, 表示数据就绪，I/O控制器等待直到CPU请求数据；当CPU发出这个请求后, I/O控制器把数据放到数据总线中，然后准备下一次的I/O操作</p>
<p>从CPU的角度来看</p>
<p>CPU发一个读命令, 然后保存当前程序的上下文环境, 转去执行其他程序；在每个指令周期的末尾，CPU检查中断：当有来自I/O控制器的中断时,CPU保存当前运行程序的上下文, 转去执行中断处理程序处理该中断；CPU从I/O控制器读一个字的数据传送到CPU的寄存器, 并存入主存，然后CPU恢复发出I/O命令的程序的上下文, 继续运行</p>
<h4 id="DMA控制方式（常用于块设备的I-O控制）"><a href="#DMA控制方式（常用于块设备的I-O控制）" class="headerlink" title="DMA控制方式（常用于块设备的I/O控制）"></a>DMA控制方式（常用于块设备的I/O控制）</h4><p>中断驱动的I/O是以字节为单位进行的，针对块设备，为了进一步减少CPU对I/O的干预，引入了直接存储器访问</p>
<p>特点</p>
<ul>
<li>数据传输的基本单位是数据块</li>
<li>所传送的数据是从设备直接送入内存的，或者相反</li>
<li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预</li>
</ul>
<h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><p>I/O通道控制方式是一种以内存为中心，实现外设与内存直接交换数据的控制方式</p>
<p>与DMA方式相比，通道所需要CPU干预更少， 每次可以完成多个不连续的数据块传送，而且可以做到一个通道控制多台设备，从而进一步减轻了CPU的负担</p>
<p>通过执行通道程序并与设备控制器共同实现对I/O设备的控制</p>
<h3 id="缓冲管理"><a href="#缓冲管理" class="headerlink" title="缓冲管理"></a>缓冲管理</h3><p>引入原因</p>
<ul>
<li>缓和CPU与I/O设备间速度不匹配的矛盾</li>
<li>提高CPU和I/O设备之间的并行性</li>
<li>减少CPU对I/O的干预，减少对CPU的中断频率， 放宽对CPU中断响应时间的限制</li>
</ul>
<h4 id="缓冲实现机制"><a href="#缓冲实现机制" class="headerlink" title="缓冲实现机制"></a>缓冲实现机制</h4><p><strong>单缓冲区</strong></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914212955182.png" alt="image-20200914212955182"></p>
<p>进程发出I/O请求时，操作系统在主存分配一个缓冲区，通过缓冲区完成I/O</p>
<ol>
<li>将一块输入数据输入缓冲区，时间T</li>
<li>系统将缓冲区数据复制到用户区，时间M</li>
<li>CPU对输入的数据处理，时间C</li>
</ol>
<p>无缓冲区时，每一块数据的处理时间为$T+C$</p>
<p>单缓冲区时，每一块数据的处理时间为$MAX(C,T)+M$</p>
<p>由于M&lt;&lt;T或C，所以上式近似为$MAX(T,C)$</p>
<p><strong>双缓冲区</strong></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914213002042.png" alt="image-20200914213002042"></p>
<p>为了加快输入和输出速度，提高设备利用率，引入了双缓冲机制，也称为缓冲对换</p>
<p>双缓冲区时，每一块数据的处理时间为$MAX(C,T)$</p>
<p><strong>环形缓冲区</strong></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914213030702.png" alt="image-20200914213030702"></p>
<p>环形缓冲区中包含多个大小相同的缓冲区，可分为三类：</p>
<ul>
<li>装输入数据的空缓冲区R</li>
<li>已装满数据的缓冲区G</li>
<li>计算进程正在使用的现行工作缓冲区C</li>
</ul>
<p><strong>缓冲池</strong></p>
<ul>
<li>缓冲区是为特定的生产者和消费者设置的，属于专用缓冲，是一组内存块的链表</li>
<li>缓冲池是公用缓冲，包含了一个管理的数据结构及一组操作函数的管理机制，用于管理多个缓冲区</li>
</ul>
<p><strong>缓冲池的组成</strong></p>
<ul>
<li>空白缓冲队列emq</li>
<li>输入队列inq</li>
<li>输出队列outq</li>
<li>四种工作缓冲区：收容输入数据的工作缓冲区、提取输入数据的工作缓冲区、收容输出数据的工作缓冲区、提取输出数据的工作缓冲区</li>
</ul>
<p><strong>缓冲池工作方式</strong></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914215936765.png" alt="image-20200914215936765"></p>
<ul>
<li>收容输入</li>
<li>提取输入</li>
<li>收容输出</li>
<li>提取输出</li>
</ul>
<h3 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I/O软件"></a>I/O软件</h3><h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><p><strong>设备独立性概念</strong>：是指用户在程序中使用的设备与实际使用的设备无关，即在用户程序中仅使用逻辑设备名，也称为<strong>设备无关性</strong></p>
<p><strong>引入设备独立性的好处</strong></p>
<ul>
<li><p>提高设备分配的灵活性</p>
</li>
<li><p>容易实现I/O重定向</p>
</li>
</ul>
<p><strong>设备独立性软件的功能</strong></p>
<ul>
<li>实现设备命名及映射</li>
<li>提供设备保护、存取控制检查</li>
<li>提供与设备无关的逻辑块</li>
<li>实现缓冲技术</li>
<li>出错处理<ul>
<li>暂时性错误</li>
<li>持久性错误</li>
</ul>
</li>
</ul>
<p><strong>设备独立性的实现：LUT</strong></p>
<p>逻辑设备表（LUT）</p>
<p>内容：逻辑设备名、物理设备名、设备驱动程序入口地址</p>
<ul>
<li>设置方式：<ul>
<li>整个系统一张表</li>
<li>每个用户一张表</li>
</ul>
</li>
</ul>
<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p><strong>设备驱动程序的功能</strong></p>
<ul>
<li>接收由上层软件发来的抽象命令， 将其转换为具体要求，并插入请求队列，如打印机驱动程序需要将打印数据从存储编码（内码）转换成输出编码（字库）</li>
<li>完成I/O操作的初始化工作：检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式</li>
<li>发出I/O命令，启动I/O设备</li>
<li>及时响应由控制器或通道发来的中断请求</li>
<li>根据用户的I/O请求，自动地构成通道程序</li>
</ul>
<p><strong>设备驱动程序的特点</strong></p>
<ul>
<li>驱动程序是请求I/O的进程与设备控制器之间的一个通信和转换程序</li>
<li>驱动程序与设备控制器和I/O设备的硬件特性紧密相关， 因而对不同类型的设备应配置不同的驱动程序</li>
<li>驱动程序与I/O设备所采用的I/O控制方式紧密相关</li>
<li>由于驱动程序与硬件紧密相关， 因而其中的一部分代码必须用汇编语言书写</li>
<li>驱动程序应允许可重入</li>
</ul>
<p><strong>设备驱动程序的处理过程</strong></p>
<ul>
<li>将抽象要求转换为具体要求</li>
<li>对服务请求进行校验</li>
<li>检查设备的状态</li>
<li>传送必要的参数</li>
<li>启动I/O设备</li>
</ul>
<h4 id="用户层I-O软件"><a href="#用户层I-O软件" class="headerlink" title="用户层I/O软件"></a>用户层I/O软件</h4><ul>
<li>系统调用<ul>
<li>应用程序通过系统调用间接调用OS中的I/O过程，对I/O设备进行操作</li>
</ul>
</li>
<li>库函数<ul>
<li>用户程序通过调用对应的库函数使用系统调用</li>
<li>C语言中的提供的I/O方面的库函数也是I/O系统的组成部分，主要包括对文件和设备进行读/写的库函数、控制/检查设备状态的库函数等</li>
</ul>
</li>
<li>假脱机系统<ul>
<li>将一台物理I/O设备虚拟为多台逻辑I/O设备</li>
</ul>
</li>
</ul>
<h3 id="SPOOLing系统"><a href="#SPOOLing系统" class="headerlink" title="SPOOLing系统"></a>SPOOLing系统</h3><h4 id="SPOOLing系统组成"><a href="#SPOOLing系统组成" class="headerlink" title="SPOOLing系统组成"></a>SPOOLing系统组成</h4><ul>
<li><p>输入井/输出井</p>
</li>
<li><p>输入缓冲区/输出缓冲区</p>
</li>
<li><p>输入进程/输出进程</p>
</li>
<li><p>井管理程序</p>
</li>
</ul>
<h4 id="SPOOLing系统特点"><a href="#SPOOLing系统特点" class="headerlink" title="SPOOLing系统特点"></a>SPOOLing系统特点</h4><ul>
<li>提高了I/O速度<ul>
<li>由对低速设备的I/O改为对输入/输出井的存取，缓和了CPU与低速设备的矛盾</li>
</ul>
</li>
<li>将独占型设备改造为共享设备</li>
<li>实现了虚拟设备功能<ul>
<li>多个进程同时（并发）地从输入/输出井存取数据，感觉是独占I/O设备</li>
</ul>
</li>
</ul>
<h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><ul>
<li>守护进程取代假脱机管理进程，是允许使用打印机的唯一进程</li>
<li>所有需要使用打印机进行打印的进程都需要将一份要求打印的文件放在假脱机文件队列（目录）中</li>
<li>如果守护进程正在睡眠，则将它唤醒，由它按照目录逐个打印，直到完成所有打印作业，然后继续睡眠</li>
</ul>
<h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><p>设备标识</p>
<p>设备号：设备绝对号（物理设备名）</p>
<h4 id="设备分配中的数据结构"><a href="#设备分配中的数据结构" class="headerlink" title="设备分配中的数据结构"></a>设备分配中的数据结构</h4><ol>
<li>设备控制表DCT：每个设备一张表</li>
<li>控制器控制表COCT：每个控制器一张表</li>
<li>通道控制表CHCT：每个通道一张表</li>
<li>系统设备表SDT中：整个系统一张表</li>
</ol>
<h4 id="设备分配考虑因素"><a href="#设备分配考虑因素" class="headerlink" title="设备分配考虑因素"></a>设备分配考虑因素</h4><ul>
<li>设备的固有属性<ul>
<li>独占设备：设备一旦分配，进程独占直至完成</li>
<li>共享设备：分配给多个进程，合理调度</li>
<li>虚拟设备：虚拟设备属于可共享设备，分配给多个进程</li>
</ul>
</li>
<li>设备分配算法<ul>
<li>先来先服务</li>
<li>优先级高者优先</li>
</ul>
</li>
<li>设备分配中的安全性<ul>
<li>安全分配方式：进程发出I/O请求后就进入阻塞状态，直至I/O操作完成，CPU与I/O设备顺序工作</li>
<li>不安全分配方式：进程发出I/O请求后继续运行，可以继续发出其他I/O请求，直到因等待设备而进入阻塞状态；为了避免死锁，进行设备分配之前要进行安全性计算</li>
</ul>
</li>
</ul>
<h4 id="设备分配过程"><a href="#设备分配过程" class="headerlink" title="设备分配过程"></a>设备分配过程</h4><ul>
<li>分配设备</li>
<li>分配控制器</li>
<li>分配通道</li>
<li>只有在设备、控制器、通道都分配成功时，设备分配才成功，可启动I/O设备进行数据传送</li>
<li><strong>改进：以逻辑设备名请求I/O</strong></li>
</ul>
<h2 id="第十章-文件系统"><a href="#第十章-文件系统" class="headerlink" title="第十章 文件系统"></a>第十章 文件系统</h2><h3 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h3><p>为了方便使用计算机系统，OS提供了信息存储的统一逻辑接口，OS对存储设备的各种属性加以抽象，从而定义了<strong>逻辑存储单元（文件）</strong>，再将文件<strong>映射到物理设备上（非易失性的，如磁盘）</strong></p>
<p>记录：一组相关数据项的集合</p>
<p>文件：文件是指由创建者所定义的、具有文件名的一组相关信息的集合</p>
<h4 id="文件系统属性"><a href="#文件系统属性" class="headerlink" title="文件系统属性"></a>文件系统属性</h4><ul>
<li>名称：人类可读形式保存的唯一信息</li>
<li>标识符：唯一标记文件系统的文件，通常是数字</li>
<li>类型：支持不同类型文件的系统所需要的信息</li>
<li>位置：指向设备与设备上文件位置的指针</li>
<li>大小：当前文件的尺寸及最大尺寸</li>
<li>保护：确定谁能读写执行操作的访问控制信息</li>
<li>时间、日期和用户标识</li>
<li>扩展文件属性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200915093457914.png" alt="image-20200915093457914"></p>
<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>按用途分类</p>
<ul>
<li>系统文件</li>
<li>用户文件</li>
<li>库文件</li>
</ul>
<p>按文件中数据形式分类</p>
<ul>
<li>源文件</li>
<li>目标文件</li>
<li>可执行文件</li>
</ul>
<p>按存取控制属性分类</p>
<ul>
<li>只执行文件</li>
<li>只读文件</li>
<li>读写文件</li>
</ul>
<p>按组织形式和处理方式分类</p>
<ul>
<li>普通文件</li>
<li>目录文件</li>
<li>特殊文件</li>
</ul>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>用于操纵和管理各种文件，方便用户使用文件的软件集合</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200915094138778.png" alt="image-20200915094138778"></p>
<h4 id="文件系统功能"><a href="#文件系统功能" class="headerlink" title="文件系统功能"></a>文件系统功能</h4><p>从用户的角度看：文件系统实现了安明存取的功能</p>
<p>从系统的角度看</p>
<ul>
<li>文件存储空间管理</li>
<li>文件读写管理</li>
<li>文件地址映射</li>
<li>文件目录管理</li>
<li>文件共享和保护</li>
</ul>
<h4 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h4><p>基本操作</p>
<ul>
<li>创建文件：分配外存空间，建立文件目录项并记录相关属性</li>
<li>删除文件：删除文件目录项，回收存储空间</li>
<li>读文件：根据用户给出的文件名查找目录，获取文件外存位置，获取文件读写指针</li>
<li>写文件：根据文件名查找目录，找到文件目录项，通过写指针进行写操作</li>
<li>设置文件的读/写位置：通过设置文件读/写指针的位置实现随机存取</li>
</ul>
<p>文件打开和关闭操作：打开文件；关闭文件</p>
<p>其他操作</p>
<ul>
<li>获取文件属性</li>
<li>设置文件属性</li>
<li>重命名文件</li>
<li>锁定文件</li>
</ul>
<h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>文件结构是指文件的构造方式</p>
<p>逻辑结构</p>
<ul>
<li>用户从使用的角度出发去组织文件，这种从<strong>用户观点</strong>出发所观察到的文件组织形式称为文件的“逻辑结构”</li>
<li>研究逻辑结构的目的：为用户提供一种逻辑结构清晰、使用简便的逻辑文件形式；用户按文件的逻辑结构形式去存储、检索和加工文件中的信息</li>
</ul>
<p>物理结构</p>
<ul>
<li>系统从<strong>存储的角度</strong>出发去组织文件，即文件在外存上的存储组织方式称为文件的“物理结构”</li>
<li>研究物理结构的目的：选择工作性能良好、设备利用率高的物理文件形式；系统按照文件的物理结构形式和外部设备打交道，控制信息的传输</li>
</ul>
<p><strong>用户按逻辑结构使用文件，文件系统按物理结构管理文件</strong></p>
<p><strong>当用户请求读写文件时，文件系统必须实现文件的逻辑结构与相应的物理结构两者之间的转换，即进行逻辑结构与物理结构之间的映射</strong></p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>有结构文件：指整个文件由若干条记录构成，也称<strong>记录式文件</strong></p>
<p>无结构文件：由一组相关信息组成的有序字符流，也称<strong>流式文件</strong></p>
<p>有结构文件—— 按文件的组织方式分类</p>
<ul>
<li>顺序文件</li>
<li>索引文件</li>
<li>索引顺序文件</li>
<li>直接文件和哈希文件</li>
</ul>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>排列方式</p>
<ul>
<li>串结构：串结构文件中的记录通常按照存入时间的先后进行排序，各记录之间的顺序与关键字无关，串结构文件的检索都必须从头开始逐个记录查找，因此比较费时</li>
<li>顺序结构：用户指定一个字段作为关键字，文件中所有记录按关键字排序，可以按关键字的大小进行排序，或按其英文字母顺序排序</li>
</ul>
<p>优缺点</p>
<ul>
<li>优点：顺序文件的最佳应用场合，是在对诸记录进行批量存取时， 即每次要读或写一大批记录，此时，对顺序文件的存取效率是所有逻辑文件中最高的</li>
<li>缺点：查找、增加或者删除记录都比较困难</li>
</ul>
<p>记录寻址</p>
<ul>
<li>隐式寻址</li>
<li>显式寻址<ul>
<li>通过文件中记录的位置</li>
<li>利用关键字</li>
</ul>
</li>
</ul>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>为文件建立一张索引表，对主文件中的每个记录，在索引表中设有一个相应表项，用于记录该记录的长度及指向该记录的记录指针（指向该记录在逻辑地址空间的首址）</p>
<p><strong>由于索引表是按记录排序的，因此，索引表本身是一个顺序文件</strong></p>
<p>变长记录顺序文件的顺序检索→定长记录索引文件的随机检索</p>
<p><strong>具有多个索引表的索引文件</strong></p>
<p>为了不同的目的，希望能按不同的属性（不同关键字）来检索一条记录，为顺序文件建立多个索引表，即为每一种可能成为检索条件的属性或关键字进行排序</p>
<p>优点：将一个需要顺序查找的文件改造成一个可随机查找的文件，极大提高了对文件的查找速度</p>
<h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p>索引顺序文件是一种常见的逻辑文件形式，它有效地克服了顺序文件的缺点，而且付出的代价不算太大，它是顺序文件和索引文件相结合的产物，将顺序文件中的所有记录分为若干个组，并为顺序文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项，其中含有该记录的键值和指向该记录的指针</p>
<p><strong>一级索引顺序文件</strong></p>
<p><strong>两级索引顺序文件</strong>为了进一步提高检索效率，可以为顺序文件建立多级索引，即为索引文件再建立一张索引表</p>
<h4 id="直接文件和哈希文件"><a href="#直接文件和哈希文件" class="headerlink" title="直接文件和哈希文件"></a>直接文件和哈希文件</h4><p><strong>直接文件</strong></p>
<p>对于直接文件，可根据给定的关键字直接获得指定记录的物理地址</p>
<p>键值转换：由关键字到记录物理地址的转换</p>
<p><strong>哈希文件</strong>：目前应用最为广泛的一种直接文件<br>利用Hash函数（或称散列函数）可将关键字转换为相应记录的地址</p>
<h3 id="文件访问方法"><a href="#文件访问方法" class="headerlink" title="文件访问方法"></a>文件访问方法</h3><p>顺序访问</p>
<p>文件信息按顺序进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read_next()<span class="comment">//读取文件的下一部分</span></span><br><span class="line">write_next()</span><br><span class="line">reset</span><br></pre></td></tr></table></figure>
<p>直接访问</p>
<p>允许程序按任意顺序进行读取和写入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read n：<span class="comment">//读取文件的第n条记录</span></span><br><span class="line">write n</span><br><span class="line">position to n</span><br></pre></td></tr></table></figure>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>目录结构用于有效管理和组织文件的结构</p>
<p>对目录管理的要求</p>
<ul>
<li>实现“按名存取”</li>
<li>有较高的目录检索速度：合理组织文件目录</li>
<li>允许文件重名</li>
<li>提供文件共享功能</li>
</ul>
<p><strong>目录结构和文件</strong>都驻留在外存（如磁盘）上</p>
<p>存储结构</p>
<p>磁盘可以整体用于一个文件系统，有时也需要在一个磁盘上装多种文件系统，或一部分用于文件系统而另一部分用于如交换区或非格式化的磁盘空间等其他地方</p>
<p>磁盘可分为不同的分区，每个分区可以创建一个文件系统</p>
<p>将<strong>存储文件系统的一大块存储空间</strong>作为<strong>卷</strong>，卷可以存放多个操作系统，使系统启动和运行多个OS；每个卷都必须包含系统上文件的信息，存放在设备目录（简称为目录）或卷表中</p>
<h4 id="常见的目录结构"><a href="#常见的目录结构" class="headerlink" title="常见的目录结构"></a>常见的目录结构</h4><p>单级目录结构</p>
<p>两级目录结构</p>
<p>树形目录结构</p>
<p>无环图目录结构</p>
<p>通用目录结构</p>
<h3 id="文件共享和保护"><a href="#文件共享和保护" class="headerlink" title="文件共享和保护"></a>文件共享和保护</h3><p>文件共享：系统允许多个用户（进程）共同使用同一个文件，系统只保存文件的一个副本</p>
<ul>
<li><p>不允许同时访问</p>
</li>
<li><p>允许同时访问</p>
<p>若允许多个用户（进程）访问一个共享文件，则文件管理系统必须强加一些规范；一种方法是当用户修改文件时，允许它锁定整个文件；另一种方法是在修改时锁定单个记录，这就是典型的读者/写者（reader/writer）问题；在设计共享访问能力时必须解决互斥问题和死锁问题</p>
</li>
</ul>
<h4 id="基于索引节点的共享方式"><a href="#基于索引节点的共享方式" class="headerlink" title="基于索引节点的共享方式"></a>基于索引节点的共享方式</h4><p>实现</p>
<ul>
<li><p>设置索引节点，存储文件的物理地址、链接计数及其他文件属性</p>
</li>
<li><p>文件目录只包括文件名和该文件对应索引节点的指针</p>
</li>
</ul>
<p>优点：任何对索引节点内容的修改对其他共享用户都是透明的</p>
<h4 id="利用符号链实现文件共享"><a href="#利用符号链实现文件共享" class="headerlink" title="利用符号链实现文件共享"></a>利用符号链实现文件共享</h4><p>实现</p>
<p>假设B为了共享C的文件F，在B中创建一个Link类型的新文件，新文件目录中只包含被链接文件F的路径名，称这种链接方法为符号链接</p>
<p>说明：只有文件主人的目录中有文件索引结点的指针，其它用户目录中只有路径名</p>
<h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><p><strong>影响文件系统安全性的主要因素</strong></p>
<ul>
<li>人为因素</li>
<li>系统因素：系统部分软件、介质故障</li>
<li>自然因素：存放在磁盘中的数据，随时间变化发生溢出或消失</li>
</ul>
<p><strong>文件保护功能：防止文件被破坏</strong></p>
<ul>
<li>防止未核准用户存取文件</li>
<li>防止一个用户冒充另一个用户存取文件</li>
<li>防止核准用户误用文件</li>
</ul>
<p><strong>保护措施</strong></p>
<ul>
<li>存取控制机制：人为因素</li>
<li>容错技术：系统因素</li>
<li>后备系统：自然因素</li>
</ul>
<p><strong>访问权</strong>：一个进程能对某对象执行操作的权力，可以用有序对（对象名，权集）表示，如$(F1, {R})$</p>
<p><strong>保护域</strong>：进程对一组对象访问权的集合，进程只能在指定域内执行操作</p>
<p><strong>进程和域间的联系方式</strong></p>
<ul>
<li>静态联系：进程和域之间一一对应，进程的生命周期中，可用资源集是固定不变的</li>
<li>动态联系：一个进程可以联系着多个域，进程的运行可划分为多个阶段，每个阶段联系着一个域，可以按照实际需求来规定进程运行各个阶段所能访问的对象</li>
</ul>
<h3 id="文件系统结构及实现"><a href="#文件系统结构及实现" class="headerlink" title="文件系统结构及实现"></a>文件系统结构及实现</h3><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><h2 id="第十一章-磁盘管理"><a href="#第十一章-磁盘管理" class="headerlink" title="第十一章 磁盘管理"></a>第十一章 磁盘管理</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><strong>磁盘</strong>为现代计算机系统提供了大容量的外存；磁盘由多个扁平圆盘的磁盘片组<br>成；每个磁盘片的双面都涂着磁质材料，通过在磁盘片上进行磁记录可以保存信息</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914233821729.png" alt="image-20200914233821729"></p>
<h4 id="磁盘物理结构"><a href="#磁盘物理结构" class="headerlink" title="磁盘物理结构"></a>磁盘物理结构</h4><ul>
<li>描述磁盘地址的参数<ul>
<li>柱面cylinder</li>
<li>磁道track</li>
<li>扇区sector</li>
</ul>
</li>
<li>逻辑块logic block<ul>
<li>最小传输单位</li>
<li>对应扇区</li>
</ul>
</li>
</ul>
<h4 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h4><p>数据传输时间$T_t$</p>
<ul>
<li>设传输的字节总数Total，磁盘转速为r转/分，一转（每个磁道）的字节数b，则$T_t=Total/rb$</li>
</ul>
<p>平均旋转延迟时间$T_r$</p>
<p>• 磁盘使所需要读取的扇区位于磁头下方，旋转一圈所需要的时间为60/r<br>• 平均旋转延迟时间为磁盘旋转半圈的时间：$ T_r =30/r$</p>
<p>寻道时间$T_s$:移动磁臂到预期读取的柱面（磁道）所需要的时间</p>
<p>假设移动一个柱面（磁道）所需时间为t，需要移动n个磁道，则$T_s=nt$</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914234526616.png" alt="image-20200914234526616"></p>
<p><strong>提高磁盘的访问速度</strong></p>
<ul>
<li>数据的合理组织</li>
<li>磁盘的高效调度</li>
</ul>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>磁盘调度：当多个磁盘访问请求在等待时，采用一定的策略，对这些请求服务按照一定顺序进行响应</p>
<p>目标：最小化寻道时间</p>
<h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><p>思想</p>
<p>选择等待队列中最先到达的访问请求，作为下一次的访问对象</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235316172.png" alt="image-20200914235316172"></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914234946125.png" alt="image-20200914234946125"></p>
<h4 id="最短寻道时间优先SSTF"><a href="#最短寻道时间优先SSTF" class="headerlink" title="最短寻道时间优先SSTF"></a>最短寻道时间优先SSTF</h4><p>思想</p>
<p>选择等待队列中离当前磁道最近的访问请求，作为下一次的访问对象（SJF调度思想的扩展）</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235326932.png" alt="image-20200914235326932"></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914234952655.png" alt="image-20200914234952655"></p>
<h4 id="扫描算法SCAN"><a href="#扫描算法SCAN" class="headerlink" title="扫描算法SCAN"></a>扫描算法SCAN</h4><p>思想</p>
<p>磁臂从磁盘的一端向另一端移动，同时当磁头移过每个柱面时，处理位于该柱面上的服务请求；当达到另一端时，磁头改变移动方向，继续处理</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235339332.png" alt="image-20200914235339332"></p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235104023.png" alt="image-20200914235104023"></p>
<h4 id="循环扫描C-SCAN"><a href="#循环扫描C-SCAN" class="headerlink" title="循环扫描C-SCAN"></a>循环扫描C-SCAN</h4><p>思想</p>
<p>将磁头从磁盘一端移到磁盘的另一端，随着移动不断地处理请求，移动到另一端时马上返回到磁盘开始，返回时不处理请求</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235348055.png" alt="image-20200914235348055"></p>
<h4 id="C-LOOK调度"><a href="#C-LOOK调度" class="headerlink" title="C-LOOK调度"></a>C-LOOK调度</h4><p>思想</p>
<p>将SCAN和C-SCAN算法中的磁头之一动到该方向上的最远的请求为止就马上掉头，就分别产生了LOOK和C-LOOK算法</p>
<p><img src="https://raw.githubusercontent.com/qq903064697/img-blog/master/images/image-20200914235416444.png" alt="image-20200914235416444"></p>
<h4 id="FSCAN调度"><a href="#FSCAN调度" class="headerlink" title="FSCAN调度"></a>FSCAN调度</h4><p>思想</p>
<p>将磁盘请求队列分为2个子队列，其中一个为当前所有请求构成的队列，另一个为扫描期间新到达的请求构成的队列，并按N步扫描处理</p>
<h4 id="各种磁盘调度算法的比较"><a href="#各种磁盘调度算法的比较" class="headerlink" title="各种磁盘调度算法的比较"></a>各种磁盘调度算法的比较</h4><ul>
<li>SSTF较为常用</li>
<li>SCAN和C-SCAN在负载较重的情况下性能更好</li>
<li>性能的取得一般依赖请求序列，而请求序列与文件分配方式相关</li>
<li>SSTF和LOOK常会选为缺省算法</li>
</ul>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h4><p>低级格式化/物理格式化——将磁盘划分成扇区以便磁盘控制器能读和写</p>
<p>扇区数据结构包括</p>
<ul>
<li>头——包含扇区号</li>
<li>数据区域</li>
<li>尾——包含纠错代码（error-correcting code，ECC）</li>
</ul>
<p>为了使用磁盘存储文件，OS还需要将自己的数据结构记录在磁盘上，分为两步</p>
<ul>
<li>分区：将磁盘分为由一个或多个柱面组成的分区</li>
<li>逻辑格式化：创建文件系统，将初始的文件系统数据结构存储在磁盘上</li>
</ul>
<h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>Bootstrap：当打开电源或重启时，计算机需要运行一个初始化程序，它初始化系统的各个方面，从CPU寄存器到设备控制器和内存，接着重启操作系统</p>
<p>只读存储器（ROM）中保留bootstrap的引导程序，大部分保存在磁盘的启动块上</p>
<p>拥有启动分区的磁盘成为启动磁盘（boot disk）/系统磁盘（system disk）</p>
<h3 id="磁盘容错技术"><a href="#磁盘容错技术" class="headerlink" title="磁盘容错技术"></a>磁盘容错技术</h3><p>通过增加冗余的磁盘驱动器、磁盘控制器等方法来提高磁盘系统可靠性的一种技术</p>
<h4 id="第一级容错技术SFT-I"><a href="#第一级容错技术SFT-I" class="headerlink" title="第一级容错技术SFT-I"></a>第一级容错技术SFT-I</h4><p>最基本的一种磁盘容错技术，主要用于防止因磁盘表面缺陷所造成的数据丢失</p>
<h4 id="第二级容错技术SFT-II"><a href="#第二级容错技术SFT-II" class="headerlink" title="第二级容错技术SFT-II"></a>第二级容错技术SFT-II</h4><p>主要用于防止由磁盘驱动器和磁盘控制器故障所导致的系统不能正常工作</p>
<h4 id="第三级容错技术SFT-III——廉价磁盘冗余阵列（RAID）"><a href="#第三级容错技术SFT-III——廉价磁盘冗余阵列（RAID）" class="headerlink" title="第三级容错技术SFT-III——廉价磁盘冗余阵列（RAID）"></a>第三级容错技术SFT-III——廉价磁盘冗余阵列（RAID）</h4><p>廉价磁盘冗余阵列（RAID）是利用一台磁盘阵列控制器来统一管理和控制一组磁盘驱动器，组成一个大型磁盘系统</p>
<p>大幅度增加了磁盘容量，极大提高了磁盘I/O速度和整个磁盘系统的可靠性</p>
<h4 id="第三级容错技术SFT-III——后备系统"><a href="#第三级容错技术SFT-III——后备系统" class="headerlink" title="第三级容错技术SFT-III——后备系统"></a>第三级容错技术SFT-III——后备系统</h4><p>三种类型</p>
<ul>
<li>磁带机<ul>
<li>适用于存储顺序文件</li>
<li>优缺点：容量大、价格低、速度慢</li>
</ul>
</li>
<li>硬盘<ul>
<li>利用活动盘，速度快，费用高</li>
<li>大容量磁盘兼做后备系统</li>
</ul>
</li>
<li>光盘驱动器<ul>
<li>优缺点：容量大、保存期长、费用适中、速度较慢</li>
</ul>
</li>
</ul>
<p>两种后备方法</p>
<ul>
<li><p>全量转储</p>
</li>
<li><p>增量转储</p>
<ul>
<li>设置转储时间表，记录每个文件最后一次的转储时间</li>
<li>每次转储时，判断在最后一次转储后是否发生变化</li>
</ul>
</li>
</ul>

    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2020/09/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" title= "数据库原理笔记">
                    <div class="nextTitle">数据库原理笔记</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/09/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" title= "我的第一篇博客文章">
                    <div class="prevTitle">我的第一篇博客文章</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:903064697@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/qq903064697" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/example_qr.png" />
                </span>
            
        
    
        
            
                <span class="iconfont-archer qq" title=qq>
                  
                  <img class="profile-qr" src="/assets/qq.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 操作系统引论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E7%BD%AE%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统的设置目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A1%AC%E4%BB%B6%E3%80%81%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统与硬件、其他软件的层次关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%8A%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%A8%E5%8A%9B"><span class="toc-number">1.6.</span> <span class="toc-text">推动操作系统发展的主要动力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.7.</span> <span class="toc-text">操作系统的发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E9%85%8D%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">未配置操作系统的计算机系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">单道批处理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">多道批处理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">分时系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.5.</span> <span class="toc-text">实时系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.6.</span> <span class="toc-text">微机操作系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E6%80%A7%E8%83%BD"><span class="toc-number">1.8.</span> <span class="toc-text">操作系统的特征和性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">1.8.1.</span> <span class="toc-text">基本特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">1.8.2.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.8.3.</span> <span class="toc-text">主要功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">第二章 操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.</span> <span class="toc-text">计算机系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">计算机硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">计算机系统结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">计算机系统运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">操作系统的运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.2.1.</span> <span class="toc-text">硬件保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.3.</span> <span class="toc-text">操作系统服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.1.</span> <span class="toc-text">单一体结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.2.</span> <span class="toc-text">层次式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">2.5.3.</span> <span class="toc-text">微内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BA-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.4.</span> <span class="toc-text">客户机-服务器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">2.5.5.</span> <span class="toc-text">模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">2.6.</span> <span class="toc-text">虚拟机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">第三章 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">3.1.</span> <span class="toc-text">前驱图和程序执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%E5%9B%BE"><span class="toc-number">3.1.1.</span> <span class="toc-text">前驱图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">3.1.2.</span> <span class="toc-text">程序顺序执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-number">3.1.3.</span> <span class="toc-text">程序并发执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.</span> <span class="toc-text">进程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">进程与程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">3.3.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PCB%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="toc-number">3.4.1.</span> <span class="toc-text">PCB主要内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCB%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.2.</span> <span class="toc-text">PCB组织方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">3.4.3.</span> <span class="toc-text">操作系统内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">3.4.4.</span> <span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">3.4.5.</span> <span class="toc-text">进程的终止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">3.5.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.5.1.</span> <span class="toc-text">消息传递系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">3.5.2.</span> <span class="toc-text">管道通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">3.6.</span> <span class="toc-text">线程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.6.1.</span> <span class="toc-text">线程与进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.2.</span> <span class="toc-text">线程类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">3.6.3.</span> <span class="toc-text">线程的执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.1.</span> <span class="toc-text">多对一模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.2.</span> <span class="toc-text">一对一模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.3.</span> <span class="toc-text">多对多模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B%E5%8F%98%E7%A7%8D"><span class="toc-number">3.7.4.</span> <span class="toc-text">二级模型：多对多模型变种</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">第四章进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">三级调度模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">进程调度的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">4.3.</span> <span class="toc-text">调度准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%89"><span class="toc-number">4.4.1.</span> <span class="toc-text">先来先服务（FCFS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%88SJF%EF%BC%89"><span class="toc-number">4.4.2.</span> <span class="toc-text">短作业优先（SJF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.4.3.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%EF%BC%88RR%EF%BC%89"><span class="toc-number">4.4.4.</span> <span class="toc-text">时间片轮转（RR）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">4.4.5.</span> <span class="toc-text">多级队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-number">4.4.6.</span> <span class="toc-text">多级反馈队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88"><span class="toc-number">4.4.7.</span> <span class="toc-text">高响应比优先</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">4.5.</span> <span class="toc-text">实时调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">4.6.</span> <span class="toc-text">多处理器调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">5.</span> <span class="toc-text">第五章 进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">进程同步相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">记录型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%89%A9%E7%90%86%E6%84%8F%E4%B9%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">信号量的物理意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.2.3.</span> <span class="toc-text">信号量的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF"><span class="toc-number">5.2.4.</span> <span class="toc-text">死锁和饥饿</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98-%E6%9C%89%E9%99%90%E7%BC%93%E5%86%B2%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.1.</span> <span class="toc-text">生产者—消费者问题&#x2F;有限缓冲问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E2%80%94%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.2.</span> <span class="toc-text">读者—写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.3.</span> <span class="toc-text">哲学家就餐问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">管程机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%AD%BB%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">第六章 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">死锁的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%89%B9%E5%BE%81"><span class="toc-number">6.2.</span> <span class="toc-text">死锁特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">死锁发生的必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">6.2.2.</span> <span class="toc-text">资源分配图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">死锁的处理方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">6.3.</span> <span class="toc-text">死锁预防</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8D%A0%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85"><span class="toc-number">6.3.1.</span> <span class="toc-text">破坏占有并等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E9%9D%9E%E6%8A%A2%E5%8D%A0"><span class="toc-number">6.3.2.</span> <span class="toc-text">破坏非抢占</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E7%8E%AF%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="toc-number">6.3.3.</span> <span class="toc-text">破环循环等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5"><span class="toc-number">6.3.4.</span> <span class="toc-text">破坏互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">6.4.</span> <span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="toc-number">6.4.1.</span> <span class="toc-text">系统的安全状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.2.</span> <span class="toc-text">资源分配图算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.3.</span> <span class="toc-text">银行家算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">6.5.</span> <span class="toc-text">死锁检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-number">6.6.</span> <span class="toc-text">死锁恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">6.6.1.</span> <span class="toc-text">进程终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%8A%A2%E5%8D%A0"><span class="toc-number">6.6.2.</span> <span class="toc-text">资源抢占</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">第七章 存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E8%83%8C%E6%99%AF"><span class="toc-number">7.1.</span> <span class="toc-text">基本概念和背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">7.1.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.1.2.</span> <span class="toc-text">存储管理的主要任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">7.1.3.</span> <span class="toc-text">存储管理的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">7.1.4.</span> <span class="toc-text">相关概念和术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">7.1.5.</span> <span class="toc-text">内存保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.6.</span> <span class="toc-text">用户处理过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-number">7.1.7.</span> <span class="toc-text">动态链接与共享库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text">连续分配存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%EF%BC%88%E5%8D%95%E7%94%A8%E6%88%B7%E5%8D%95%E4%BB%BB%E5%8A%A1OS%EF%BC%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">单一连续分配（单用户单任务OS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">7.2.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">7.2.3.</span> <span class="toc-text">动态分区分配&#x2F;可变分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.4.</span> <span class="toc-text">动态分区分配算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%8E%E7%89%87"><span class="toc-number">7.3.</span> <span class="toc-text">碎片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">7.4.</span> <span class="toc-text">覆盖和交换技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">7.4.1.</span> <span class="toc-text">覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-number">7.4.2.</span> <span class="toc-text">交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">7.5.</span> <span class="toc-text">分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%80%9D%E6%83%B3"><span class="toc-number">7.5.1.</span> <span class="toc-text">分页思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">7.5.2.</span> <span class="toc-text">直接地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">7.5.3.</span> <span class="toc-text">具有快表的地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%A1%B5"><span class="toc-number">7.5.4.</span> <span class="toc-text">共享页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">7.5.5.</span> <span class="toc-text">二级页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="toc-number">7.5.6.</span> <span class="toc-text">反置页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">7.6.</span> <span class="toc-text">分段存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%80%9D%E6%83%B3"><span class="toc-number">7.6.1.</span> <span class="toc-text">分段思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%9A%84%E4%BF%9D%E6%8A%A4%E5%92%8C%E5%85%B1%E4%BA%AB"><span class="toc-number">7.6.2.</span> <span class="toc-text">分段的保护和共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%AF%94%E8%BE%83"><span class="toc-number">7.7.</span> <span class="toc-text">分页与分段存储管理比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">7.8.</span> <span class="toc-text">段页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">7.8.1.</span> <span class="toc-text">基本思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%99%9A%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">第八章 虚存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">请求分页存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5"><span class="toc-number">8.2.1.</span> <span class="toc-text">请求分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.2.</span> <span class="toc-text">请求页表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.3.</span> <span class="toc-text">缺页中断机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%80%E8%88%AC%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.</span> <span class="toc-text">缺页中断与一般中断的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">8.3.1.</span> <span class="toc-text">地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">8.3.2.</span> <span class="toc-text">请求分页性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="toc-number">8.4.1.</span> <span class="toc-text">基本页面置换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-1"><span class="toc-number">8.4.2.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%EF%BC%88FIFO%EF%BC%89%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.3.</span> <span class="toc-text">先进先出（FIFO）页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%EF%BC%88Optimal%EF%BC%89%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.4.</span> <span class="toc-text">最佳（Optimal）置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%EF%BC%88LRU%EF%BC%89%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.5.</span> <span class="toc-text">最近最少使用（LRU）页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%91%E4%BC%BCLRU%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.6.</span> <span class="toc-text">近似LRU页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%AE%BF%E9%97%AE%E4%BD%8D%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.6.1.</span> <span class="toc-text">附加访问位算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95%EF%BC%88Clock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">8.4.6.2.</span> <span class="toc-text">二次机会算法（Clock置换算法）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.7.</span> <span class="toc-text">计数页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%EF%BC%88LFU%EF%BC%89%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.7.1.</span> <span class="toc-text">最不经常使用（LFU）页面置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B8%B8%E4%BD%BF%E7%94%A8%EF%BC%88MFU%EF%BC%89%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.7.2.</span> <span class="toc-text">最常使用（MFU）页面置换算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">8.5.</span> <span class="toc-text">页框分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%88%86%E9%85%8D%E4%B8%8E%E5%B1%80%E9%83%A8%E5%88%86%E9%85%8D"><span class="toc-number">8.5.1.</span> <span class="toc-text">全局分配与局部分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">8.6.</span> <span class="toc-text">请求分页系统性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8"><span class="toc-number">8.6.1.</span> <span class="toc-text">抖动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.6.2.</span> <span class="toc-text">工作集模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%8A%96%E5%8A%A8"><span class="toc-number">8.7.</span> <span class="toc-text">预防抖动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-I-O%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.</span> <span class="toc-text">第九章 I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.1.</span> <span class="toc-text">I&#x2F;O系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">9.1.1.</span> <span class="toc-text">I&#x2F;O系统的基本功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.2.</span> <span class="toc-text">I&#x2F;O系统的层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.1.3.</span> <span class="toc-text">I&#x2F;O系统接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.1.4.</span> <span class="toc-text">I&#x2F;O设备设备类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.1.5.</span> <span class="toc-text">设备与控制器之间的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">9.1.6.</span> <span class="toc-text">设备控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-O%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.7.</span> <span class="toc-text">I&#x2F;O系统结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.1.</span> <span class="toc-text">程序直接控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E7%9A%84I-O%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">9.2.2.</span> <span class="toc-text">中断驱动I&#x2F;O控制方式（常用于字符设备的I&#x2F;O控制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%EF%BC%88%E5%B8%B8%E7%94%A8%E4%BA%8E%E5%9D%97%E8%AE%BE%E5%A4%87%E7%9A%84I-O%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">9.2.3.</span> <span class="toc-text">DMA控制方式（常用于块设备的I&#x2F;O控制）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.4.</span> <span class="toc-text">通道控制方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E7%AE%A1%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">缓冲管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">9.3.1.</span> <span class="toc-text">缓冲实现机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%BD%AF%E4%BB%B6"><span class="toc-number">9.4.</span> <span class="toc-text">I&#x2F;O软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="toc-number">9.4.1.</span> <span class="toc-text">设备独立性软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.4.2.</span> <span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82I-O%E8%BD%AF%E4%BB%B6"><span class="toc-number">9.4.3.</span> <span class="toc-text">用户层I&#x2F;O软件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPOOLing%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.5.</span> <span class="toc-text">SPOOLing系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SPOOLing%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="toc-number">9.5.1.</span> <span class="toc-text">SPOOLing系统组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPOOLing%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9"><span class="toc-number">9.5.2.</span> <span class="toc-text">SPOOLing系统特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">9.5.3.</span> <span class="toc-text">守护进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="toc-number">9.6.</span> <span class="toc-text">设备分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.6.1.</span> <span class="toc-text">设备分配中的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-number">9.6.2.</span> <span class="toc-text">设备分配考虑因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">9.6.3.</span> <span class="toc-text">设备分配过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.</span> <span class="toc-text">第十章 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.1.</span> <span class="toc-text">文件和文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7"><span class="toc-number">10.1.1.</span> <span class="toc-text">文件系统属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.1.2.</span> <span class="toc-text">文件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.1.3.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD"><span class="toc-number">10.1.4.</span> <span class="toc-text">文件系统功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">10.1.5.</span> <span class="toc-text">文件的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">10.2.</span> <span class="toc-text">文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">10.2.1.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">10.2.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">10.2.3.</span> <span class="toc-text">顺序文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">10.2.4.</span> <span class="toc-text">索引文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">10.2.5.</span> <span class="toc-text">索引顺序文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%96%87%E4%BB%B6%E5%92%8C%E5%93%88%E5%B8%8C%E6%96%87%E4%BB%B6"><span class="toc-number">10.2.6.</span> <span class="toc-text">直接文件和哈希文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">文件访问方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">10.4.</span> <span class="toc-text">目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">10.4.1.</span> <span class="toc-text">常见的目录结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BF%9D%E6%8A%A4"><span class="toc-number">10.5.</span> <span class="toc-text">文件共享和保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">10.5.1.</span> <span class="toc-text">基于索引节点的共享方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%AC%A6%E5%8F%B7%E9%93%BE%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">10.5.2.</span> <span class="toc-text">利用符号链实现文件共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">10.5.3.</span> <span class="toc-text">文件保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.6.</span> <span class="toc-text">文件系统结构及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">10.7.</span> <span class="toc-text">文件的物理结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">10.8.</span> <span class="toc-text">空闲空间管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">第十一章 磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-number">11.1.</span> <span class="toc-text">磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">11.1.1.</span> <span class="toc-text">磁盘物理结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4"><span class="toc-number">11.1.2.</span> <span class="toc-text">磁盘访问时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-number">11.2.</span> <span class="toc-text">磁盘调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1FCFS"><span class="toc-number">11.2.1.</span> <span class="toc-text">先来先服务FCFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88SSTF"><span class="toc-number">11.2.2.</span> <span class="toc-text">最短寻道时间优先SSTF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95SCAN"><span class="toc-number">11.2.3.</span> <span class="toc-text">扫描算法SCAN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8FC-SCAN"><span class="toc-number">11.2.4.</span> <span class="toc-text">循环扫描C-SCAN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-LOOK%E8%B0%83%E5%BA%A6"><span class="toc-number">11.2.5.</span> <span class="toc-text">C-LOOK调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FSCAN%E8%B0%83%E5%BA%A6"><span class="toc-number">11.2.6.</span> <span class="toc-text">FSCAN调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">11.2.7.</span> <span class="toc-text">各种磁盘调度算法的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">11.3.1.</span> <span class="toc-text">磁盘格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-number">11.3.2.</span> <span class="toc-text">引导块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AF"><span class="toc-number">11.4.</span> <span class="toc-text">磁盘容错技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AFSFT-I"><span class="toc-number">11.4.1.</span> <span class="toc-text">第一级容错技术SFT-I</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AFSFT-II"><span class="toc-number">11.4.2.</span> <span class="toc-text">第二级容错技术SFT-II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%BA%A7%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AFSFT-III%E2%80%94%E2%80%94%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97%EF%BC%88RAID%EF%BC%89"><span class="toc-number">11.4.3.</span> <span class="toc-text">第三级容错技术SFT-III——廉价磁盘冗余阵列（RAID）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%BA%A7%E5%AE%B9%E9%94%99%E6%8A%80%E6%9C%AFSFT-III%E2%80%94%E2%80%94%E5%90%8E%E5%A4%87%E7%B3%BB%E7%BB%9F"><span class="toc-number">11.4.4.</span> <span class="toc-text">第三级容错技术SFT-III——后备系统</span></a></li></ol></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 11
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2020/10/28/HTML%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" >HTML基本知识</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/17</span><a class="archive-post-title" href= "/2020/10/17/Leetcode%E7%AC%AC%E5%9B%9B%E9%A2%98/" >Leetcode第四题：合并两个有序链表</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span><a class="archive-post-title" href= "/2020/10/13/Leetcode%E7%AC%AC%E4%B8%89%E9%A2%98/" >Leetcode第三题：罗马数字转整数</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2020/10/10/Leetcode%E7%AC%AC%E4%BA%8C%E9%A2%98/" >Leetcode第二题：整数反转</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/07</span><a class="archive-post-title" href= "/2020/10/07/Leetcode%E7%AC%AC%E4%B8%80%E9%A2%98/" >Leetcode第一题：两数之和</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2020/09/27/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" >数字图像处理笔记</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2020/09/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" >数据库原理笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span><a class="archive-post-title" href= "/2020/09/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/" >我的第一篇博客文章</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2020/09/27/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AC%94%E8%AE%B0/" >软件工程笔记</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/25</span><a class="archive-post-title" href= "/2020/10/25/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" >灰度图像处理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2020/09/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" >操作系统原理笔记</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "John Doe"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


